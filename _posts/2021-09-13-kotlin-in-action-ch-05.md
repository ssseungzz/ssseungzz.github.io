---
title: "Kotlin in Action 5장; 람다로 프로그래밍"
categories:
  - Language
tags:
  - kotlin
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 5. 람다로 프로그래밍

#### 5.1 람다 식과 멤버 참조

* 람다 식을 사용하면 함수 선언 없이 코드 블록을 직접 함수의 인자로 전달할 수 있다.
* 코틀린에서는 라이브러리 함수를 통해 컬렉션을 원하는 대로 쉽게 다룰 수 있다.
  * 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수도 있다.

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31))
people.maxBy { it.age } // 중괄호로 둘러싸인 코드는 비교에 사용할 값을 돌려주는 함수

people.mayBy(Person::age)
```

* 람다 식 문법은 아래와 같다.
  * 중괄호 사이에 파라미터와 본문으로 이루어져 있다. 화살표는 인자 목록과 람다 본순을 구분해 준다.
  * 변수에 저장 가능하다.

```kotlin
val sum = { x: Int, y: Int -> x + y}
println(sum(1, 2)) // 3
```

* 코드 일부분을 블록으로 둘러싸 실행할 필요가 있다면 `run`을 사용한다. 인자로 받은 람다를 실행해 준다.

```kotlin
people.maxBy({ p: Person -> p.age })
```

* 컴파일러가 문맥으로부터 유추할 수 있는 인자 타입은 굳이 적을 필요 없으며 인자가 하나뿐인 경우 이름을 붙이지 않아도 된다.
* 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다.
  * 람다가 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.

```kotlin
people.maxBy { p: Person -> p.age }
```

* 컴파일러는 람다 파라미터 타입도 추론할 수 있으므로 파라미터 타입을 명시할 필요가 없다.
  * 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 `it`을 바로 쓸 수 있다.

```kotlin
people.maxBy { it.age }
```

* 람다를 변수에 저장 시 파라미터의 타입을 추론할 문맥이 없으므로 타입을 명시해야 한다.

##### 현재 영역에 있는 변수에 접근

* 람다 정의의 앞에 선언된 로컬 변수도 람다에서 사용 가능하다.
* 람다 안에서 바깥의 변수를 변경해도 되고, 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수도 있다.
  * 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수'라고 부른다. 
* 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 포획한 변수를 쓸 수 있다.
  * 파이널 변수를 포획한 경우 람다 코드를 변수 값과 함께 저장한다. 
  * 파이널이 아닌 변수를 포획한 경우 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음 래퍼에 대한 참조를 람다 코드와 함께 저장한다.
* 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다.

```kotlin
fun tryToCountButtonClicks(button: Button): Int {
  var clicks = 0
  button.onClick { clicks++ } // 핸들러는 함수 반환 뒤 호출
  return clicks
}
```

##### 멤버 참조

* 함수를 값으로 바꿀 수 있다.

```kotlin
val getAge = Person::age
```

* `::`를 사용하는 식을 멤버 참조라고 한다.
  * 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어 준다.
  * `::`는 클래스 이름과 참조하려는 멤버 이름 사이에 위치한다.
  * 멤버 참조 뒤에는 괄호를 넣으면 안 된다.
* 최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다.

```kotlin
fun salute() = println("Salute")
run(::salute) // 최상위 함수 참조
```

* 람다가 인자가 여럿인 다른 함수한테 작업을 위임하는 경우 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다.

```kotlin
val action = { person: Person, message: String -> sendEmail(person, message) }
val nextAction = ::sendEmail
```

* `::` 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.
* 확장 함수도 멤버 참조 구문을 사용해 참조를 얻을 수 있다. (ex - `Person::isAdult`)



#### 5.2 컬렉션 함수형 API

##### 필수적인 함수: filter와 map

* `filter` 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨 람다가 `true`를 반환하는 원소만 모은다.
* 원소를 변환할 때는 `map` 함수를 사용한다. 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아 새 컬렉션을 만든다.

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31))
people.filter { it.age > 30 }
people.map(Person::name)
```

* 꼭 필요한 경우가 아니면 계산을 반복하지 않는 것이 좋다. 람다를 넘기면 겉으로 볼 때는 단순해 보이지만 내부 로직의 복잡도로 실제로는 불합리한 계산식시 될 수 있다.
* 필터와 변환 함수를 맵(자료 구조)에 적용할 수도 있다.

###### all, any, count, find: 컬렉션에 술어 적용

* 컬렉션의 원소가 조건을 만족하는지 판단하거나 조건을 만족하는 원소의 개수 혹은 만족하는 첫 번째 원소를 반환한다.

```kotlin
val canBeInClub27 = { p: Person -> p.age <= 27 }
people.all(canBeInClub27)
```

* `find`는 만족하는 원소가 전혀 없으면 `null`을 반환한다.

###### groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31) ... Person("Carol", 31))
people.groupBy { it.age }
```

* 람다식의 결과가 키가 되고, 키 값에 따라 그룹이 값인 맵이 된다.

###### flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리

* `flatMap` 함수는 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.

```kotlin
val strings = listOf("abc", "def")
string.flatMap { it.toList() }
```

![](https://oracle-patches.com/images/2021/02/11/Kotlin-22.jpg)

* 특별히 변환할 것 없이 리스트의 리스트를 평평하게 펼치는 경우 `listOfLists.flatten()` 처럼 `flatten` 함수를 사용할 수 있다.



#### 5.3 지연 계산(lazy) 컬렉션 연산

* 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고 컬렉션 연산을 연쇄할 수 있다.
* 중간 연산을 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 좋아진다.

```kotlin
people.asSequence()
		.map(Person::name)
		.fileter { it.startsWith("A") }
		.toList()
```

* 코틀린 지연 계산 시퀀스는 `Sequence` 인터페이스에서 시작한다. 
  * `iterator` 라는 하나의 메소드를 통해 시퀀스로부터 원소 값을 얻을 수 있다.

##### 시퀀스 연산 실행: 중간 연산과 최종 연산

* 연산은 중간 연산과 최종 연산으로 나뉜다.
  * 중간 연산은 다른 시퀀스를 반환한다. 항상 지연 계산된다. 
  * 최종 연산은 결과를 반환한다. 최종 연산이 호출되면 연기됐던 모든 계산이 수행된다.
* 시퀀스의 모든 연산은 각 원소에 대해 순차적으로 적용된다.
  * 원소에 연산을 차례대로 적용하다 결과가 얻어지면 그 이후의 원소에 대해서는 변환이 이루어지지 않을 수 있다.
  * 반면 컬렉션의 경우 중간 단계의 모든 원소에 연산을 적용한다.
* 연산의 순서도 성능에 영향을 미친다. 가령, `filter`를 먼저 수행하면 부적절한 원소를 먼저 제외할 수 있다.

##### 시퀀스 만들기

* `generateSequence`를 호출해 시퀀스를 만들 수 있다. 
  * 이전의 원소를 인자로 받아 다음 원소를 계산한다.
  * 첫 번째 원소를 지정하고 시퀀스의 한 원소로부터 다음 원소를 계산하는 방법을 제공함으로써 시퀀스를 만든다.



#### 5.4 자바 함수형 인터페이스 활용

* 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다.
* 추상 메소드가 단 하나만 있는 인터페이를 함수형 인터페이스 또는 SAM(Single Abstarct Method) 인터페이스라고 한다.
  * 코틀린에서는 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해 준다.

##### 자바 메소드에 람다를 인자로 전달

* 함수형 인터페이스를 인자로 갖는 자바 메소드에 코틀린 람다를 전달하면 컴파일러는 자동으로 무명 클래스와 인스턴스를 만들어 준다.
  * 이때 그 무명 클래스에 있는 유일한 추상 메소드를 구현할 때 람다 본문을 메소드 본문으로 사용한다.
  * 무명 객체를 명시적으로 만들어서 사용할 수도 있다. 이 경우 메소드 호출 시마다 새로운 객체가 생성된다.
  * 람다는 정의가 들어 있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 메소드를 호출할 때마다 반복 사용한다.
* 람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수 없다.
  * 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해 준다.

##### SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경

* 반환하고픈 람다를 SAM 생성자로 감싼다.
  * 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다.
  * 그 함수형 인터페이스의 유일한 추상 메소드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.

```kotlin
fun createAllDoneRunnable(): Runnable {
  return Runnable { println("All done") }
}
createAllDoneRunnable().run()
```

* 람다로 생성한 함수형 인터페이스 인스턴스를 변수에 저장해야 하는 경우에도 SAM 생성자를 사용할 수 있다.
* 람다는 컴파일러 입장에서 보면 코드 블록일 뿐이므로 무명 객체와 달리 인스턴스 자신을 가리키는 `this`가 없다는 점에 유의하자.
  * 람다 안에서 `this`는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다.



#### 5.5 수신 객체 지정 람다: with와 apply

* 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 한다.
  * 이런 람다를 수신 객체 지정 람다라고 부른다.

##### with 함수

````kotlin
fun alphabet(): String {
  val stringBuilder = Stringbuilder()
  return with (stringbuilder) {
    for (letter in 'A'..'Z') {
      this.append(letter)
    }
    append("the alphabet")
    this.toString()
  }
}
````

* `with`문은 파라미터가 2개 있는 함수이다.
  * 두 번째 파라미터는 람다가 된다.
  * 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 람다 본문에서는 `this`를 사용해 수신 객체에 접근할 수 있다.
  * `with`가 반환하는 값은 람다 코드를 실행한 결과이다.
* 인자로 넘긴 객체의 클래스와 `with`를 사용하는 코드가 들어 있는 클래스 안에 이름이 같은 메소드가 있다면 `this@OuterClassName` 으로 호출하고 싶은 메소드를 정확히 지정 가능하다.

##### apply 함수

* `apply`는 항상 자신에게 전달된 객체를 반환한다.

````kotlin
fun alphabet() = StringBuilder().apply {
  for (letter in 'A'..'Z') {
    append(letter)
  }
  append("the alphabet")
}
````

* `apply`는 확장 함수로 정의돼 있으며 `apply`의 수신 객체가 전달받은 람다의 수신 객체가 된다.
