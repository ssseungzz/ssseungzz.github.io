---
title: "Modern Java in Action 21장; 결론 그리고 자바의 미래"
categories:
  - Language
tags:
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 21. 결론 그리고 자바의 미래

#### 21.1 자바 8의 기능 리뷰
* 변화가 생긴 이유는 아래 두 가지 추세 때문이라고 할 수 있다.
  * 멀티코어 프로세서의 파워를 충분히 활용해야 한다. 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있다.
  * 데이터 소스를 이용해서 주어진 조건과 일치하는 데이터 추출, 연산 적용 등 선언형으로 데이터를 처리하는 방식, 즉 간결하게 데이터 컬렉션을 다뤄야 한다. 이를 가능하게 하려면 불변값을 생산할 수 있는 불변 객체와 컬렉션이 필요하다.

##### 21.1.1 동작 파라미터화(람다와 메서드 참조)
* 메서드로 전달되는 값은 `Function<T, R>`, `Predicate<T>`, `BiFunction<T, U, R>` 등의 형식을 가지며 수선한 코드에서는 `apply`, `test` 등의 메서드로 코드를 실행할 수 있다.

##### 21.1.2 스트림

* 컬렉션은 여러 연산 적용 시 각각의 연산 때마다 컬렉션을 탐색해야 한다.
* 스트림 API는 이들 연산을 파이프라인이라는 게으른 형식의 연산으로 구성하며 한 번의 탐색으로 파이프라인의 모든 연산을 수행한다. 
* 또한 멀티코어 CPU를 활용해서 병렬로 요소를 처리하는 기능도 중요하다. `parallel` 메서드는 스트림을 병렬로 처리하도록 지정하는 역할을 한다.
  * 상태 변화는 병렬성의 가장 큰 걸림돌이으모 함수형 개념은 `map`, `filter` 등의 연산을 활용하는 스트림 병렬 처리의 핵심이다. (부작용 없는 연산, 람다와 메서드 참조로 파라미터화된 메서드 등)

##### 21.1.3 CompletableFuture 클래스
* `Future` 인터페이스를 활용하면 여러 작업이 동시에 실행될 수 있도록 다른 스레드나 코어로 작업을 할당할 수 있다. 다른 작업을 생성한 기존 작업에서 결과가 필요할 때는 `get` 메서드를 호출해서 생성된 `Future`가 완료될 때까지 기다릴 수 있다.
  * `CompletableFuture`는 `Future`와 관련한 공통 디자인 패턴을 함수형 프로그래밍으로 간결하게 표현할 수 있도록 여러 메서드(`thenCompose`, `thenCombine`, `allOf` 등)를 제공한다.


##### 21.1.4 Optional 클래스
* 에러가 발생할 수 있는 계산을 수행하면서 값이 없을 때 에러를 발생시킬 수 있는 `null` 대신 정해진 데이터 형식을 제공할 수 있다.
* 계산 연결 시 함수형으로 `map`, `filter` 등을 활용할 수 있고 값이 없는 상황을 라이브러리에서 확인할 수 있다.

##### 21.1.5 Flow API
* 리액티브 스트림과 리액티브 당김 기반 역압력 프로토콜을 표준화했다.


##### 21.1.6 디폴트 메서드
* 인터페이스 설계자가 메서드의 기본 구현을 제공할 수 있다.

#### 21.2 자바 9 모듈 시스템
* 자바 9의 핵심은 새 모듈 시스템으로 `module-info.java` 파일이 추가되었지만 언어적으로는 바뀐 것이 없다.
* 자바 모듈 시스템은 언어 수준의 기법으로 큰 시스템과 자바 런타임 자체를 모듈화했다.
  * 안정적 설정: 모듈 요구사항을 명시적으로 선언함으로써 의존성 빠짐, 충돌, 순환 등의 문제를 런타임이 아니라 빌드 과정에서 일찍 확인할 수 있다.
  * 강한 캡슐화: 자바 모듈 시스템은 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분과 내부 구현의 영역 접근을 분리할 수 있다.
  * 성능 개선: 클래스가 런타임에 로드된 다른 클래스를 참조하는 상황보단느 적은 수의 컴포넌트를 참조할 때 최적화 기술이 더 효과를 발휘한다.
  * 확장성: 자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로써 실행 중인 애플리케이션에서 필요한 부분만 사용할 수 있다.

#### 21.3 자바 10 지역 변수형 추론
* 자바에서는 기본적으로 변수나 메서드를 정의할 때 형식을 지정해야 하지만 시간이 지나면서 엄격한 형식 지정이 조금 느슨해졌다.
* 컨텍스트로 형식을 유추할 수 있는 상황에서는 제너릭의 형식 파라미터를 생략할 수 있다. (ex - `Map<String, List<String>> myMap = new HashMap<>();`)
  * 람다의 경우도 마찬가지다. (ex - `Function<Integer, Boolean> p = x -> booleanExpression;`)
* 형식이 생략되면 컴파일러가 생략된 형식을 추론한다.
* 지역 변수의 형식을 `var` 키워드로 대체하고 컴파일러가 변수 할당문 오른쪽 내용을 기초로 형식을 추론하는 것을 지역 변수형 추론이라고 하며 자바 10에 추가된 기능이다.

#### 21.4 자바의 미래


##### 21.4.1 선언 사이트 변종
* 자바에서는 제네릭의 서브 형식을 와일드카드로 지정할 수 있는 유연성(사용 사이트 변종)을 허용한다. 아래처럼 제네릭을 지정할 수 있다.


```java
List<? extends Number> numbers = new ArrayList<Integer>();
```


* 하지만 `? extends` 가 없으면 컴파일 에러가 발생한다. 
  * 많은 프로그래밍 언어는 선언 사이트 변종이라는 다른 변종 기법을 지원한다. 이를 이용하면 제네릭 클래스 정의 시 프로그래머가 변종을 지정할 수 있다.
  * 선언 사이트 변종에서는 `? extends`나 `? super`를 사용할 필요가 없다.

##### 21.4.2 패턴 매칭

```java
switch (someExpr) {
  case (op instance of BinOp):
    doSomething(op.getOpName(), op.getLeft(), op.getRight());
  case (n instanceof Number):
    dealWithNode(n.getValue());
  default:
    defaultAction(someExpr);
}
```

* 위 예제에서 `op`는 새로운 지역 변수로 `someExpr`과 같은 값으로 바운드되며 `n`은 `Number` 형식의 변수가 된다. `default` 케이스에서는 아무 변수도 바운드되지 않는다.
* 이 제안을 적용하면 if-then-else 그리고 서브형식 캐스팅에 사용되는 여러 불필요한 코드를 제거할 수 있다.


##### 21.4.3 풍부한 형식의 제네릭

###### 구체화된 제네릭

* 제네릭이 기존 JVM과 호환성을 유지하기 위해 어떤 타입이든 런타임 표현이 같게 되었다. 이를 제네릭 다형석의 삭제 모델이라고 한다.
  * 이 때문에 제네릭 형식의 파라미터로 객체만 사용할 수 있게 되었다.
  * 런타임에 형식 정보를 확인할 수 없으므로 특정 요소가 객체 참조인지 아니면 기본값(GC 수행 불가)인지 분간할 수 없다.
* 자바에서는 `ArrayList<String>`, `ArrayList<Integer>` 등과 같은 선언이 모두 같은 상황이라면 가비지 컬렉션이 필드가 참조인지 기본형인지 알 수 있도록 형식 정보를 런타임에 유지해야 한다.
  * 이를 제네릭 다형성 구체화 모델, 또는 구체화된 제네릭이라고 부른다.

###### 제네릭이 함수 형식에 제공하는 문법적 유연성

* 람다는 코드 표현을 풍부할 수 있게 해 주었지만 형식 시스템은 이를 따라잡지 못한다.
  * 많은 함수형 언어에서는 `(Integer, Double) => String`이라는 형식을 구현할 수 있는데 자바 8에서는 `BiFunction<Integer, Double, String>`에 해당한다.

###### 기본형 특화와 제네릭

* 자바의 모든 기본형에는 대응하는 객체형이 존재한다.
  * `Function<Apple, Boolean>`이 아니라 `Predicate<Apple>`로 구현해야 하는 이유는 후자의 객체형을 호출했을 때 기본형 `boolean`을 반환하기 때문이다. 
  * 반면 모든 제네릭과 마찬가지로 `Function`도 객체형으로만 파라미터화할 수 있다. `Function<Apple, Boolean>`의 객체형은 기본형 `boolean`이 아니라 객체형 `Boolean`이다.
  * `Predicate<Apple>`은 `boolean`을 박싱할 필요가 없어서 효율적인데, 이런 이유로 `LongToIntFunction`과 같은 복잡한 인터페이스가 등장하게 됐다.
  * 구체화된 제네릭으로 이런 문제를 해결할 수 있다.

##### 21.4.4 더 근본적인 불변성 지원
* 자바에서 함수형 프로그래밍을 구현하려면 불변값을 언어적으로 지원해야 한다. `final`로는 필드값 갱신만 막을 수 있으므로 불변값이라는 목표를 달성하기 어렵다.
* 가령 `final int[] arr = {1, 2, 3};`이라는 변수가 있다면 다른 값은 할당할 수 있지만 `arr[1] = 2;`처럼 요소는 바꿀 수 있다.

##### 21.4.5 값 형식

###### 컴파일러가 Integer와 int를 같은 값으로 취급할 수는 없을까?
* 기본형에서는 비트를 비교해서 같음을 판단하지만 객체에서는 참조로 같음을 판단하므로 같은 값으로 취급하기 어렵다.
* 따라서 기본형으로 해결할 수 있는 상황임에도 컴파일러 요구사항에 맞춰 객체를 생성하는 상황이 발생할 수 있다.

###### 변수형: 모든 것을 기본형이나 객체형으로 양분하지 않는다.
* 기본형이 아닌 모든 것은 객체형이므로 `Object`를 상속받으며 모든 참조는 객체 참조라는 자바의 가정을 조금 바꾸면 문제를 해결할 수 있을 것이다.
  * 객체형은 `final`로 정의되지 않았을 때 변화할 수 있는 필드를 포함하며 `==`로 값이 같음을 검사할 수 있다.
  * 값 형식은 불변이며 참조 식별자를 포함하지 않는다. 기본형값은 넓은 의미에서 값 형식의 일종이다.
* 사용자가 값 형식을 정의하도록 허용할 수 있다.
  * 값 형식은 `==`도 기본적으로 요소 단위의 비교로 값이 같은지 확인한다.
  * 참조 식별자가 없으므로 저장 공산을 적게 차지한다.
  * 데이터 접근(여러 수준에 걸친 포인터 참조 대신 단일 인덱스 주소 명령어를 사용하므로)뿐만 아니라 데이터의 근접성 덕분에 하드웨어 캐시 활용에도 좋은 성능을 제공할 가능성이 크다.

![](https://user-images.githubusercontent.com/55083845/162585371-f8cc6488-819c-4767-90c8-889b18714739.jpeg)

* 또한 값 형식에는 참조 식별자가 없으므로 컴파일러가 자유롭게 값 형식을 박싱하거나 언박싱할 수 있다.