---
title: "JPA 뽀개기 - 고급 매핑"
categories:
  - Develop
tags:
  - jpa
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 7. 고급 매핑

#### 상속 관계 매핑

* ORM에서 이야기하는 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것이다.
* 세 가지 방법을 선택할 수 있다.
  * 각각의 테이블로 변환: 각각을 모두 테이블로 만들고 조회할 때 조인을 사용한다. 조인전략이라고 한다.
  * 통합 테이블로 변환: 테이블을 하나만 사용해서 통합한다. 단일 테이블 전략이라고 한다.
  * 서브타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만든다. 구현 클래스마다 테이블 전략이라고 한다.

##### 조인 전략

* 엔티티 각가을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략이다. 조회할 때 조인을 자주 사용한다. 
* 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없으므로 타입을 구분하는 컬럼을 추가해야 한다.
  * `@Inheritance(strategy = InheritanceType.JOINED)`: 상속 매핑은 부모 클래스에 `@Inheritance` 를 사용해야 한다. 조인 전략을 사용할 때는 전략을 `InheritanceType.JOINED` 로  설정한다.
  * `@Discriminator(name = "DTYPE")`: 부모 클래스에 구분 커럼을 지정한다. 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다.
  * `@DiscriminatorValue("M")`: 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다.
* 기본적으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면 `@PrimaryKeyJoinColumn`을 사용하면 된다.
* 조인 전략의 장점은 아래와 같다.
  * 테이블의 정규화
  * 외래 키 참조 무결정 제약 조건 활용 가능
  * 저장 공간 효율적 사용
* 조인 전략의 단점은 아래와 같다.
  * 조회할 때 사용되는 조인으로 인한 성능 저하
  * 조회 쿼리의 복잡함
  * 데이터 등록 시 INSERT SQL 두 번 사용

##### 단일 테이블 전략

* 이름 그대로 테이블을 하나만 사용한다.
* 구분 컬럼으로 어떤 자식 데이터가 저장되었는지 구분한다.
* 조회 시 조인을 사용하지 않으므로 일반적으로 가장 빠르다.
* 자식 엔티티가 사용한 컬럼은 모두 `null`을 허용해야 한다.
* `@Inheritance(InheritanceType.SINGLE_TABLE)` 로 지정하면 단일 테이블 전략을 사용한다.
* 단일 테이블 전략의 장점은 아래와 같다.
  * 조인이 필요 없으므로 조회 성능 향상
  * 조회 쿼리 단순
* 단일 테이블 전략의 단점은 아래와 같다.
  * 자식 엔티티가 매핑한 컬럼은 모두 `null` 허용해야
  * 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음, 따라서 상황에 따라 조회 성능이 느릴 수 있음
* 주의점
  * 구분 컬럼을 꼭 사용해야 한다. 따라서 `@DiscriminatorColumn`을 꼭 설정해야 한다.
  * `@DiscriminatorValue`를 지정하지 않으면 기본으로 엔티티 이름을 사용한다.

##### 구현 클래스마다 테이블 전략

* 자식 엔티티마다 테이블을 만든다.
* `@Inheritance(InheritanceType_TABLE_PER_CLASS)`를 사용하면 구현 클래스마다 테이블 전략을 사용한다. 일반적으로 추천하지 않는 전략이다.
* 구현 클래스마다 테이블 전략의 장점
  * 서브 타입을 구분해서 처리 시 효과적
  * `not null` 제약 조건 사용 가능
* 구현 클래스마다 테이블 전략의 단점
  * 여러 자식 테이블 함께 조회 시 성능 나쁨(SQL에 UNION 사용해야)
  * 자식 테이블 통합해서 쿼리하기 어려움



#### @MappedSuperclass

* 부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 `@MappedSuperclass`를 사용하면 된다.
* 실제 테이블과 매핑되지 않으며 매핑 정보를 상속할 목적으로만 사용된다.
  * 자식 엔티티에서 부모로부터 물려받은 매핑 정보를 재정의하려면 `@AttributeOverrides`나 `@AttributeOverride`를 사용하고 연관관계를 재정의하려면 `@AssociationOverrides`나  `@AssociationOverride`를 사용한다.
* 이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 게 낫다.
* ORM에서 이야기하는 진정한 상속 매핑은 객체 상속을 데이터베이스의 **슈퍼타입 서브타입 관계와 매핑**하는 것이다.



#### 복합 키와 식별 관계 매핑

##### 식별 관계 vs 비식별 관계

* 식별 관계
  * 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계다.
* 비식별 관계
  * 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다.
  * 비식별 관계는 외래 키에 `NULL`을 허용하는지에 따라 필수적 비식별 관계와 선택적 비식별 관계로 나뉜다.
    * 필수적 비식별 관계: 외래 키에 `NULL`을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.
    * 선택적 비식별 관계: 외래 키에 `NULL`을 허용한다. 연관관계를 맺을지 선택할 수 있다.
    * 최근에는 주로 비식별 관계를 사용하면서 꼭 필요한 곳에만 식별 관계를 사용한다.

##### 복합 키: 비식별 관계 매핑

* JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 한다.
* JPA는 영속성 컨텍스트에 엔티티를 보관할 때 엔티티의 식별자를 키로 사용한다. 그리고 식별자를 구분하기 위해 `equals`와 `hashCode`를 사용해서 동등성을 비교한다.
  * 식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고 그곳에 `equals` 와 `hashCode`를 구현해야 한다.

###### `@IdClass`

* JPA에서 복합 키를 지원하는 방법 중 하나이다.
* 각가의 기본 키 컬럼을 `@Id`로 매핑하고 `@IdClass`를 사용해서 식별자 클래스를 지정한다.
* 식별자 클래스는 아래 조건을 만족해야 한다.
  * 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
  * `Serializable` 인터페이스를 구현해야 한다.
  * `equals`, `hashCode`를 구현해야 한다.
  * 기본 생성자가 있어야 한다.
  * 식별자 클래스는 `public`이어야 한다.
* 부모 테이블의 기본 키 컬럼이 복합 키일 때 자식 테이블의 외래 키도 자연히 복합 키가 된다. 따라서 외래 키 매핑 시 여러 컬럼을 매핑해야 하므로 `@JoinColumns` 어노테이션을 사용한다.

###### `@EmbeddedId`

* JPA에서 복합 키를 지원하는 방법 중 하나로 `@IdClass`보다 좀 더 객체 지향적이다.
* 부모 엔티티에서 식별자 클래스를 직접 사용하고 `@EmbeddedId` 어노테이션을 적어 주면 된다.
  * `@EmbeddedId`를 적용한 식별자 클래스는 식별자 클래스에 기본 키를 직접 매핑한다.
* `@EmbeddedId`를 적용한 식별자 클래스는 아래의 조건을 만족해야 한다.
  * `@Embeddable` 어노테이션을 붙여 주어야 한다.
  * `Serializable` 인터페이스를 구현해야 한다.
  * `equals`, `hashCode`를 구현해야 한다.
  * 기본 생성자가 있어야 한다.
  * 식별자 클래스는 `public`이어야 한다.

###### 복합 키와 equals(), hashCode()

* 자바의 모든 클래스는 기본으로 `Object` 클래스를 상속받는데 이 클래스가 제공하는 기본 `equals()`는 **인스턴스 참조 값 비교**인 `==` 비교(동일성 비교)를 한다.
* 영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리하며 식별자 비교 시 `equals()`, `hashCode()`를 사용한다.
  * 따라서 식별자 객체의 동등성이 지켜지지 않으면 영속성 컨텍스트가 엔티티를 관리할 때 문제가 발생할 수 있다.
  * 복합 키는 필수적으로 `equals()`, `hashCode()`를 구현해야 한다.

##### 복합 키: 식별 관계 매핑

###### `@IdClass`와 식별 관계

* 식별 관계는 기본 키와 외래 키를 같이 매핑해야 한다. 따라서 식별자 매핑인 `@Id`와 연관관계 매핑인 `@ManyToOne`을 같이 사용하면 된다.

###### `@EmbeddedId`와 식별 관계

* `@EmbeddedId` 로 식별 관계 구성 시 `@MapsId`를 사용해야 한다.
  * 식별 관계로 사용할 연관관계의 속성에 `@MapsId`를 사용하면 된다.
  * 외래 키와 매핑한 연관관계를 기본 키에도 매핑하겠다는 의미이다.
  * `@MapsId`의 속성 값은 `@EmbeddedId`를 사용한 식별자 클래스의 기본 키 필드를 지정하면 된다.

##### 비식별 관계로 구현

* 복합 키가 없으므로 복합 키 클래스를 만들 필요가 없다.
* 매핑이 쉽고 코드가 단순하다.

##### 일대일 식별 관계

* 일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용한다.
  * 따라서 부모 테이블의 기본 키가 복합 키가 아니면 자식 테이블의 키는 복합 키로 구성하지 않아도 된다.

##### 식별, 비식별 관계의 장단점

* 데이터베이스 설계 관점에서 비식별 > 식별
  * 식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어난다.
  * 식별 관계는 2개 이상의 컬럼을 합해서 복합 기본 키를 만들어야 하는 경우가 많다.
  * 식별 관계를 사용할 떄 기본 키로 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많은데 식별 관계의 자연 키 컬럼들이 자식에 게 전파되면 변경이 힘들다.
  * 식별 관계는 테이블 구조가 유연하지 못하다.
* 객체 관계 매핑 관점에서 비식별 > 식별
  * JPA에서 복합 키는 별도의 복합 키 클래스를 만들어서 사용해야 한다.
  * 비식별 관계의 기본 키는 주로 대리 키를 사용하는데 JPA는 `@GeneratedValue`처럼 대리 키를 생성하기 위한 편리한 방법을 제공한다.
* 식별 관계는 기본 키 인덱스를 활용하기 좋고 상위 테이블의 기본 키 컬럼을 자식들이 가지고 있으므로 특정 상황에서는 조인 없이 하위 테이블만으로 검색을 완료할 수 있다는 장점이 있다.
* 가장 추천되는 방법은 **비식별 관계를 사용하고 기본 키는 `Long` 타입의 대리 키를 사용**하기 + 필수적 비식별 관계를 사용하는 것이다.



#### 조인 테이블

* 데이터베이스 테이블의 연관관계를 설계하는 방법
  * 조인 컬럼 사용(외래 키)
  * 조인 테이블 사용(테이블 사용)

* 조인 컬럼 사용
  * 조인 컬럼이라 부르는 외래 키 컬럼을 사용해서 관리한다.
  * 외래 키에 `null`을 허용하는 관계는 선택적 비식별 관계라고 부른다.
* 조인 테이블 사용
  * 조인 테이블이라는 별도의 테이블을 사용해서 연관관계를 관리한다.
  * 연관관계를 관리하는 조인 테이블을 추가하고 여기서 두 테이블의 외래 키를 가지고 연관관계를 관리한다.
  * 테이블을 추가해야 한다는 단점이 있으므로 기본적으로 조인 컬럼을 사용하고 필요한 경우 조인 테이블을 쓰는 게 낫다.

##### 일대일 조인 테이블

* 일대일 관계를 만들려면 조인 테이블의 외래 키 컬럼 각각에 총 2개의 유니크 제약 조건을 걸어야 한다.
  * `@JoinColumn` 대신 `@JoinTable` 사용
    *  `name`: 매핑할 조인 테이블 이름
    * `joinColumns`: 현재 엔티티를 참조하는 외래 키
    * `inverseJoinColumns`: 반대 방향 엔티티를 참조하는 외래 키

* 양방향으로 매핑하려는 경우 반대 방향에 `@OneToOne`과 `mappedBy` 속성을 사용한다.

##### 일대다 조인 테이블

* 일대다 관계는 조인 테이블의 컬럼 중 다와 관련된 컬럼에 유니크 제약 조건을 걸어야 한다.

##### 다대일 조인 테이블

* 일대다에서 방향만 반대이다.

##### 다대다 조인 테이블

* 조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약 조건을 걸어야 한다.
* 조인 테이블에 컬럼을 추가하면 `@JoinTable`을 사용할 수 없다. 
  * 새로운 엔티티를 만들어 조인 테이블과 매핑해야 한다.



#### 엔티티 하나에 여러 테이블 매핑

* `@SecondaryTable`을 사용해서 `@Table`에 사용된 테이블 외에 다른 테이블에도 엔티티를 매핑할 수 있다.
  * `name`: 매핑할 다른 테이블의 이름
  * `pkJoinColumns`: 매핑할 다른 테이블의 기본 키 컬럼 속성
* `@Column.table`로 어떤 테이블의 컬럼에 매핑할지 지정할 수 있다. 지정하지 않으면 기본 테이블(`@Table`)에 매핑된다.