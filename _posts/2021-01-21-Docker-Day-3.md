---
title: 도커 스웜과 도커 컴포즈
categories:
  - Infra
tags:
  - docker
toc: true
toc_label: "Contents"
toc_sticky: true
---

### Docker Day 3 - 도커 스웜과 도커 컴포즈

##### 왜 도커 스웜을 사용할까?

* 하나의 호스트 머신에서 도커 엔진을 구동하다가 자원이 부족한 경우 가장 많이 사용하는 해법은 여러 대의 서버를 클러스터로 만들어 자원을 병렬로 확장하는 것이다.
* 그러나 여러 대의 서버를 하나의 자원 풀로 만들기 위해서는 새로운 서버나 컨테이너가 추가됐을 때 이를 발견하는 작업부터 어떤 서버에 컨테이너를 할당할 것인가에 대한 스케줄러와 로드밸런서 문제, 고가용성 보장 문제 등이 발생한다.
  * 이를 해결할 여러 솔루션 중 하나가 도커 스웜과 스웜 모드이다.

> 고가용성(High Availability): 고가용성이란 서버와 네트워크, 프로그램 등의 정보 시스템이 상당히 오랜 기간 동안 지속적으로 정상 운영이 가능한 성질을 말한다.



##### 도커 스웜의 종류와 구조

* 도커 스웜의 종류
  * 컨테이너로서의 스웜(스웜 클래식): 여러 대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점 제공, 일반적인 도커 명령어와 도커 API로 클러스터의 서버를 제어하고 관리
  * 도커 스웜 모드: 마이크로서비스 아키텍처의 컨테이너를 다루기 위한 클러스터링 기능에 초점, 같은 컨테이너를 동시에 여러 개 생성해서 필요에 따라 유동적으로 개수 조절, 로드밸런싱 기능 자체 지원
    * 클러스터에 영입할 서버 발견, 클러스터의 설정 저장, 데이터 동기화 등에 주로 사용되는 분산 코디네이터가 내장(컨테이너로서의 스웜은 X)
    * 자주 사용(컨테이너로서의 스웜은 레거시)

* 도커 스웜 모드의 구조
  * 매니저 노드와 워커 노드로 구성된다. 워커 노드는 컨테이너가 생성되고 관리되는 도커 서버이고 매니저 노드는 워커 노드를 관리하기 위한 도커 서버이다. 매니저 노드에도 컨테이너가 생성될 수는 있지만 워커 노드와 매니저 노드를 구분해서 사용하는 것이 권장된다.
  * 스웜 모드는 매니저 노드의 절반 이상에 장애가 생겨 정상적으로 작동하지 못한 경우 복구될 때까지 클러스터의 운영을 중단한다.
  * 매니저 노드는 일반적인 매니저 역할을 하는 노드와 리더 역할을 하는 노드로 나뉜다. 리더 매니저는 모든 매니저 노드에 대한 데이터 동기화와 관리를 담당하므로 항상 작동할 수 있는 상태여야 한다. 리더 매니저의 서버가 다운되는 장애가 생기면 매니저는 새로운 리더를 선출한다. 이때 Raft Consensus 알고리즘이 사용된다.



##### 어떻게 사용할까? - 도커 스웜 모드 명령어 살펴보기

* `docker swarm init --adviertise-addr <public-ip-address>`: 매니저 역할을 할 서버에서 스웜 클러스터 시작한다. 다른 노드가 이 노드에 접근할 수 있도록 매니저 노드의 public IP를 입력한다.
  * `docker swarm join \ --token <token-value> \ <public-ip-address>`가 출력되는데, 이를 워커 노드 역할을 할 서버에서 입력하면 스웜 클러스터에 추가된다.
* `docker node ls`: 매니저 노드에서 스웜 클러스터 노드의 목록을 알 수 있다. ID 옆에 `*`가 붙어 있는 상태인 경우 사용 가능한 상태이다.
* `docker swarm join-token manager`: 새로운 매니저 노드를 추가하기 위한 명령어로 출력 결과에서 매니저 노드를 추가할 수 있는 명령어와 토큰 값을 확인할 수 있다.
* `docker swarm join-token --rotate [manager | worker]`: 매니저나 워커 토큰을 갱신한다. 매니저 노드에서만 수행 가능하다.
* `docker swarm leave`: 추가된 워커 노드를 삭제한다. 해당 워커 노드에서 입력한다.
  * 매니저 노드에서 `docker node rm <hostname>`을 해 주어야 해당 워커 노드가 삭제된다.
  * 매니저 노드는 `docker swarm leave --force`로 삭제할 수 있다. 해당 노드에 저장돼 있던 클러스터의 정보도 삭제되므로 주의해야 한다.
* `docker node promote/demote`: 워커 노드를 매니저 노드로 변경하거나 매니저 노드를 워커 노드로 변경한다. 매니저 노드가 1개일 때는 `demote`가 불가능하다. 



##### 스웜 모드 서비스

* 스웜 모드의 제어 단위는 컨테이너가 아닌 서비스(service)이다.
  * 서비스는 같은 이미지에서 생성된 컨테이너의 집합이다. 서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령이 수행된다. 
  * 서비스 내에 컨테이너는 1개 이상 존재 가능하고, 컨테이너들은 각 워커 노드와 서비스 노드에 할당된다. 이러한 컨테이너들을 태스크(task)라고 한다.

* 가령, `ubuntu:14.04` 이미지로 서비스를 생성하고 태스크의 수를 3개로 설정했다면 스웜 스케줄러는 서비스의 정의에 따라 컨테이너를 할당할 적합한 노드를 선정하고, 해당 노드에 태스크를 분산해서 할당한다. 
  * 함께 생성된 태스크(컨테이너)를 레플리카라고 하며, 서비스에 설정된 레플리카의 수만큼의 태스크가 스웜 클러스터 내에 존재해야 한다.
  * 스웜은 서비스의 태스크들에 대한 상태를 확인하다가 서비스 내에 정의된 레플리카의 수만큼 태스크가 존재하지 않으면 새로운 태스크(컨테이너) 레플리카를 생성한다.
* 서비스 장애(서비스의 태스크가 정지, 특정 노드 다운 등)가 발생하면 스웜 매니저는 새로운 컨테이너를 생성해 자동으로 이를 복구한다. 다만 정상적인 상태를 회복해도 장애를 복구하기 위해 다른 노드로 옮겨진 태스크가 해당 노드에 자동으로 설정되지는 않으므로, 서비스 태스크 할당의 균형을 맞추기 위해서는 `scale` 명령어를 사용해 컨테이너의 수를 조절해야 한다.
* 서비스는 롤링 업데이트 기능을 제공한다.

> 롤링 업데이트는 여러 개의 서버, 컨테이너 등으로 구성된 클러스터의 설정이나 데이터 등을 변경하기 위해 하나씩 재시작하는 것을 의미한다.

###### 명령어 살펴보기

* `docker serivce create \ <image-name> \ command`: 특정 이미지를 사용해서 서비스 내의 컨테이너를 생성해서 명령어를 수행한다.

  * 서비스 내의 컨테이너는 detached 모드로 동작할 수 있는 이미지를 사용해야 한다. 컨테이너 내부를 차지하고 있는 프로세스가 없어 컨테이너가 정지되면 스웜 매니저는 서비스의 컨테이너에 장애가 생긴 것으로 판단해 컨테이너를 계속 생성한다.
  * `--replicas` 옵션으로 레플리카 수를 설정할 수 있다.
  * `-p` 옵션으로 포트를 설정할 수 있다. 이는 스웜 클러스터 자체에 포트를 개방한 것으로 생각할 수 있다.
  * `--mode global` 옵션을 추가하면 글로벌 모드로 서비스를 생성한다. 

  > 서비스의 모드는 두 가지로 하나는 레플리카 셋의 수를 정의해 그만큼의 같은 컨테이너를 생성하는 복제 모드로서 실제 서비스를 제공하기 위해 일반적으로 쓰인다. 다른 하나는 글로벌 모드로 스웜 클러스터 내에서 사용할 수 있는 모든 노드에 컨테이너를 반드시 하나씩 생성한다. 따라서 글로벌 모드로 생성한 서비스는 레플리카 셋의 수를 별도로 지정하지 않는다.

* `docker service ls`: 스웜 클러스터 내의 서비스 목록을 보여 준다.

* `docker service ps <service-name`>: 서비스의 자세한 정보를 확인한다.

* `docker service rm <service-name>`: 서비스를 삭제한다.

* `docker service scale`: 컨테이너의 개수를 조절할 수 있다. `서비스 이름=레플리카 수`를 입력해 주면 원하는 수만큼 조절 가능하다.

  * 스웜 모드는 라운드 로빈 방식으로 서비스 내에 접근할 태스크를 결정한다.

* `docker service update \ --image <image-name> \ <service-name`: 특정 이미지를 사용해서 롤링 업데이트를 수행한다.

  * 서비스 생성 시 롤링 업데이트의 주기, 업데이트를 동시에 진행할 컨테이너의 개수 등을 설정 가능하다.
  * 이러한 설정은 `docker service inspect`로 확인 가능하다.

* `docker node update \ --availability active \ <hostname>`: Active 상태가 아닌 노드를 Active 상태로 변경한다. 

  * `--availability` 옵션을 `drain`으로 주면 해당 노드에 컨테이너를 할당하지 않으며 실행 중인 컨테이너가 중지되고, `pause`로 주면 컨테이너를 더는 할당받지 않지만 실행 중인 컨테이너가 중지되지는 않는다.

  * `--label-add`로 라벨을 설정할 수 있다.

  * 서비스 생성 시 `--constraint` 옵션에서 노드 라벨을 사용하여 서비스의 컨테이너가 할당될 노드의 종류를 선택할 수 있다.

    > 노드의 ID, 이름 및 역할로도 제약 조건을 설정할 수 있다.

###### 서비스 태스크(컨테이너)에 설정 정보 전달하기

* 서버 클러스터에서 설정 파일을 호스트마다 마련해 두는 것은 비효율적이고 보안 상의 문제도 발생할 수 있다. 이를 위해 스웜 모드는 `secret`과 `config`라는 기능을 제공한다.

* `docker secret create`: `secret`을 생성한다. 
  * 생성 후 조회해도 실제로 값을 확인할 수는 없다. 매니저 노드 간에서 암호화된 상태로 저장된다.
* `--secret` 옵션을 통해 컨테이너로 공유된 값은 기본적으로 컨테이너 내부의 `/run/secrets/` 디렉터리에 마운트 된다.

```bash
docker service create \
--name mysql \
--replicas 1 \
--secret source=my_mysql_password,target=mysql_root_password \
--secret source=my_mysql_password,target=mysql_password \
-e MYSQL_ROOT_PASSWORD_FILE="/run/secrets/mysql_root_password" \
-e MYSQL_PASSWORD_FILE="/run/secrets/mysql_root_password" \
...
```

* `config`를 사용하는 방법은 `secret`과 거의 동일하다.
* `docker config create registry-config config.yml`: 레지스트리의 설정 파일을 `registry-config`라는 이름의 `config`로 저장한다.

###### 도커 스웜 네트워크

* 스웜 모드는 여러 개의 도커 엔진에 같은 컨테이너를 분산해서 할당하므로 각 도커 데몬의 네트워크가 하나로 묶인 네트워크 풀이 필요하다.
* 서비스를 외부로 노출했을 때 어느 노드로 접근하더라도 해당 서비스의 컨테이너에 접근할 수 있게 라우팅 기능이 필요하다.
* `docker network ls`: 네트워크 목록 확인
  * `docker_gwbridge`와 `ingress` 네트워크가 존재한다. 전자는 스웜에서 오버레이 네트워크를 사용할 때 사용되고, 후자는 로드 밸런싱과 라우팅 메시에 사용된다.
* `ingress` 네트워크
  * 스웜 클러스터를 생성하면 자동으로 등록되는 네트워크로 스웜 모드를 사용할 때만 유효하다.
  * 어떤 스웜 노드에 접근하더라도 서비스 내의 태스크에 접근할 수 있게 설정하는 라우팅 메시를 구성하고 서비스 내의 태스크에 대한 접근을 라운드 로빈 방식으로 분산하는 로드 밸런싱을 담당한다.

![](https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/replication.png)

* 오버레이 네트워크
  * `ingress` 네트워크는 오버레이 네트워크 드라이브를 사용한다. 오버레이 네트워크는 여러 개의 도커 데몬을 하나의 네트워크 풀로 만드는 네트워크 가상화 기술의 일종으로 여러 개의 도커 데몬에 존재하는 컨테이너가 서로 통신할 수 있다. 여러 개의 스웜 노드에 할당된 컨테이너는 오버레이 네트워크의 서브넷에 해당하는 IP 대역을 할당받고 이 IP를 통해 서로 통신할 수 있다.

![](https://user-images.githubusercontent.com/55083845/105280177-819ea780-5bec-11eb-9bd8-31187d509651.png)

* `docker_gwbridge` 네트워크
  * `ingress` 를 포함한 모든 오버레이 네트워크는 기본적으로 존재하는 브리지 네트워크와는 다른 브리지 네트워크인 `docker_gwbridge` 네트워크와 함께 사용된다.
  * 외부로 나가는 통신 및 오버레이 네트워크의 트래픽 종단점 역할을 담당한다.
  * 컨테이너 내부의 네트워크 인터페이스 카드 중 `eth1`과 연결된다.
* 사용자 정의 오버레이 네트워크
  * `docker network create`와 비슷하게 간단하게 사용자 정의 오버레이 네트워크를 생성할 수 있다.
  * `-d` 옵션을 명시해서 네트워크 드라이버를 `overlay`로, `--subnet` 옵션을 사용해서 오버레이 네트워크 서브넷을 설정해 준다.

```bash
docker network create \
--subnet 10.0.9.0/24 \
-d overlay \
myoverlay
```

###### 서비스 디스커버리

* 도커 스웜 모드는 서비스 발견 기능을 자체적으로 지원한다. 2개의 컨테이너 레플리카를 갖는 B 서비스가 있고, A 서비스가 B 서비스의 컨테이너를 사용한다고 할 때 B 서비스의 컨테이너의 수가 달라져도 A 서비스는 B라는 이름으로 서비스 B의 컨테이너에 모두 접근할 수 있다.
  * 서비스 이름은 어떻게 각 컨테이너의 IP로 변환된 것일까? 
    * 호스트 이름은 여러 개의 IP를 가지는 게 아니라 서비스의 VIP를 가진다.



##### 도커 컴포즈는 왜 사용할까?

* 여러 개의 컨테이너가 하나의 애플리케이션으로 동작한다고 가정해 보자.
  * 예를 들어, 지난 포스팅에서는 데이터베이스 컨테이너와 스프링 부트 애플리케이션 컨테이너를 각각 `run` 해 주고 나서야 정상적으로 애플리케이션을 사용할 수 있었다. 이렇게 여러 개의 컨테이너로 구성된 애플리케이션을 구축하기 위해 `run`을 여러 번 사용할 수도 있지만 동작을 확인하기 위해 매번 이러한 방식을 사용하는 것은 번거로울 것이다.
  * 여러 개의 컨테이너를 하나의 서비스로 정의해 컨테이너 묶음으로 관리하는 게 더 편리할 것이다.
  * 이를 위해 도커 컴포즈(compose)는 컨테이너를 이용한 서비스의 개발과 CI를 위해 여러 개의 컨테이너를 하나의 프로젝트로서 다룰 수 있는 작업 환경을 제공한다.
* 도커 컴포즈는 여러 개의 컨테이너의 옵션과 환경을 정의한 파일을 읽어 컨테이너를 순차적으로 생성하는 방식으로 동작한다. 
  * 설정 파일은 `run` 명령어의 옵션을 그대로 사용할 수 있고, 각 컨테이너의 의존성, 네트워크 볼륨 등을 함께 정의할 수 있다.
  * 스웜 모드의 서비스와 유사하게 설정 파일에 정의된 컨테이너 수를 유동적으로 조절하고 컨테이너의 서비스 디스커버리도 자동으로 이루어진다.

###### 도커 컴포트 설치 및 기본 사용

* 윈도우나 맥 OS X에서는 도커 툴박스나 Docker for Windows, Docker for Mac을 설치하면 도커 엔진과 함께 도커 컴포즈도 설치된다.

```bash
docker-compose -v
docker-compose version 1.27.4, build 40524192
```

* 도커 컴포즈는 컨테이너의 설정이 정의된 YAML 파일을 읽어 도커 엔진을 통해 컨테이너를 생성하기 때문에 도커 컴포즈를 사용하려면 먼저 YAML 파일을 작성해야 한다.

```
version: '3.0'
services:
  web:
    image: alicek106/composetest:web
    ports:
      - "80:80"
    links:
      - mysql:db
    command: apachectl -DFOREGROUND
  mysql:
    image: alicek106/composetest:mysql
    command: mysqld
```

* YAML 파일이 저장된 디렉터리에서 `docker-compose up -d`로 컨테이너를 생성한다.
  * `version`: YAML 파일 포맷에 버전을 나타낸다. 도커 컴포즈 버전마다 사용하는 버전이 다르고, 도커 엔진 버전과 도커 컴포즈 버전에는 의존성이 있으므로 버전을 확인해서 쓰자.
  * `services`: 생성될 컨테이너들을 묶어 놓은 단위로 각 컨테이너에 적용될 생성 옵션을 지정한다.
  * `web`, `mysql`: 생성될 서비스의 이름으로 이 항목 아래에 컨테이너가 생성될 때 필요한 옵션을 지정할 수 있다. `docker run`에서 사용하는 옵션과 동일하게 `image`, `ports` 등을 지정할 수 있다. 
  * 명령어 끝에 서비스의 이름을 입력하면 특정 서비스의 컨테이너만 생성할 수 있다.
* 도커 컴포즈는 컨테이너를 프로젝트 및 서비스 단위로 구분하므로 컨테이너의 이름은 일반적으로 `[프로젝트 이름]_[서비스 이름]_[서비스 내에서 컨테이너의 번호]`와 같은 형식으로 정해진다.

> 도커 컴포즈는 기본적으로 현재 디렉터리의 이름으로 된 프로젝트를 제어한다. `-p` 옵션을 통해 제어할 프로젝트의 이름을 명시할 수도 있다.

![](https://user-images.githubusercontent.com/55083845/105289688-89197d00-5bfb-11eb-94dd-13836bddce55.png)

* `docker-compose scale` 명령어로 서비스에 존재하는 컨테이너의 수를 조절할 수 있다.
* `docker-compose down` 명령어로 생성된 프로젝트를 삭제할 수 있다.

###### YAML 파일 작성 뜯어 보기

* 결국 도커 컴포즈 사용법의 대부분은 YAML 파일을 작성하는 것에 있다고 볼 수 있다.
* YAML 파일은 크게 버전 정의, 서비스 정의, 볼륨 정의, 네트워크 정의의 항목으로 구성된다.
  * 가장 많이 사용하는 것은 서비스 정의이며, 나머지 항목은 서비스로 생성된 컨테이너에 선택적으로 사용된다.
  * 각 항목의 하위 항목은 두 개의 공백으로 들여쓰기해서 구분한다.
* 버전 정의
  * 버전 1, 2, 2.1, 3 등이 있고 도커 컴포즈 버전에 맞추어 사용한다.
  * 파일의 맨 윗부분에 명시한다.
* 서비스 정의
  * 서비스는 도커 컴포즈로 생성할 컨테이너 옵션을 정의한다. 각 서비스는 컨테이너로 구현되며 하나의 프로젝트로 도커 컴포즈에 의해 관리한다. 서비스의 이름은 `services`의 하위 항목으로 정의하고, 컨테이너 옵션은 서비스 이름의 하위 항목에 정의한다.
  * 서비스 항목이 가질 수 있는 주요 컨테이너 옵션을 아래와 같다. 다른 자세한 항목은 [공식 문서](docs.docker.com/compose/compose-file/)에서 볼 수 있다.
    * `image`: 서비스의 컨테이너를 생성할 때 쓰일 이미지의 이름을 설정한다. 이미지 이름 포맷은 `docker run`과 같다.
    * `links`: `docker run --link`와 같으며 다른 서비스에 서비스명만으로 접근할 수 있도록 설정한다. 
    * `environment`: `docker run -e` 옵션과 동하다. 컨테이너 내부에서 사용할 환경 변수를 지정한다.
    * `command`: 컨테이너가 실행될 때 수행할 명령어를 설정한다.
    * `depends_on`: 특정 컨테이너에 대한 의존 관계를 나타내며, 이 항목에 명시된 컨테이너가 먼저 생성되고 실행된다.
    * `ports`: 서비스의 컨테이너를 개방할 포트를 설정한다. 단일 호스트 환경에서 호스트의 특정 포트를 서비스의 컨테이너와 연결하면 서비스의 컨테이너 수를 늘릴 수 없다.
    * `build`: 이 항목에 정의된 도커파일에서 이미지를 빌드해 컨테이너를 생성하도록 설정한다. 도커파일에 사용될 컨텍스트나 이름 등을 설정할 수도 있다.
    * `extends`: 다른 YAML 파일이나 현재 YAML 파일에서 서비스 속성을 상속받게 설정한다. 하위 항목에 다른 YAML 파일과 서비스를 정의할 수 있다.
* 네트워크 정의
  * `driver`: 도커 컴포즈는 기본적으로 브리지 타입의 네트워크를 생성하지만 YAML 파일에서 다른 네트워크를 사용하도록 설정할 수 있다. 특정 드라이버에 필요한 항목은 `driver_ops`라는 하위 항목으로 전달할 수 있다.
  * `ipam`: IPAM(IP Address Manager)를 위해 사용할 수 있는 옵션으로 subnet, ip 범위 등을 설정할 수 있다.
  * `external`: 기존의 네트워크를 사용하도록 설정한다. 외부 네트워크의 이름을 하위 항목으로 입력한 뒤에 `external`의 값을 `true`로 설정한다.
* 볼륨 정의
  * `driver`: 볼륨을 생성할 때 사용될 드라이버를 설정한다.
  * `external`: 도커 컴포즈는 YAML 파일에서 `volume`, `volumes-from` 옵션 등을 사용하면 프로젝트마다 볼륨을 생성하는데, 매번 생성하지 않고 기존 볼륨을 사용하도록 설정한다.
* YAML 파일 검증
  * `docker-compose config`를 통해 오타 검사나 파일 포맷 등을 검사할 수 있다. 
* YAML 파일에 네트워크 항목을 정의하지 않으면 프로젝트별로 브리지 타입의 네트워크를 생성한다. 생성된 네트워크의 이름은 `[프로젝트 이름]_default`로 설정된다. `docker-compose [up | down]`으로 생성되고 삭제된다.

###### 도커 스웜 모드와 함께 사용하기

* 도커 컴포즈 1.10 버전에서 스웜 모드와 함께 사용할 수 있는 YAML 버전 3이 배포됨과 동시에 스웜 모드와 함께 사용되는 개념인 스택(stack)이 추가되었다. 스택은 YAML 파일에서 생성된 컨테이너의 묶음으로 YAML 파일로 스택을 생성하면 YAML 파일에 정의된 서비스가 스웜 모드의 클러스터에서 일괄적으로 생성된다.
* 즉, *YAML 파일에 정의된 서비스가 스웜 모드의 서비스로 변환*된 것이다.
  * `docer stack`으로 제어한다.
* `docker stack deploy -c <yaml-file-name> <stack-name`>으로 스택을 생성할 수 있다. `--config-file` 또는 `-c` 옵션으로 YAML 파일을 지정한다. 
  * 컨테이너 간의 의존성을 정의하는 항목은 사용할 수 없다. 양 컨테이너가 같은 호스트에 생성되어야 하기 때문이다.
* `docker stack ls`로 확인 가능하고 `docker stack ps <stac-name>` 명렁으로 특정 서비스에 존재하는 컨테이너를 확인할 수 있다. 서비스의 이름은 `[스택 이름]_[YAML 파일에 정의된 서비스의 이름]`으로 구성된다.
* 스택은 스웜 킷에 의해 생성되므로 `docker service scale`을 사용해 컨테이너의 수를 조절한다. 삭제는 `docker stack rm <stack-name>`으로 가능하다.
* 스택도 스택을 위한 네트워크가 자동으로 생성되며, 도커 컴포즈의 네트워크와 달리 오버레이 네트워크 속성을 가지며 스웜 클러스터에서 사용하도록 설정된다.

###### 참고: 도커 내부 구조?

* 도커 사는 중립적인 입장에서 컨테이너 표준을 정의하는 OCI(Open Container Initiative)를 발표했고, 여기에는 컨테이너를 구성하기 위해 공통적으로 구현돼야 하는 런타임 및 이미지 스펙의 표준을 정의한다.
* Moby라는 큰 프로젝트에서 도커 컨테이너 기술을 관리하기 시작했고, 도커는 runC, containerd 그리고 도커 엔진으로 분리되었다.
* 도커의 핵심 프로세스로 도커 데몬(`dockerd`)을 떠올리기 쉽지만, 도커 데몬은 컨테이너가 아니다. 실제로 컨테이너 프로세스로 부를 만한 것은 **runC**이며, 컨테이너에 1:1로 매칭되는 런타임 역할을 runC가 담당한다. 여러 개의 runC 컨테이너 프로세스 및 이미지를 관리하는 주체가 containerd이다. `dockerd`는 containerd와 통신해 runC를 사용할 수 있도록 하는 엔드 유저용 도구이다.

###### 실습: 도커 컴포즈를 사용해 스프링 프로젝트 배포해 보기

* 이전 글에서 사용한 이미지를 그대로 사용했다.
* 따로 네트워크 설정 없이 도커 컴포즈가 생성해 주는 브리지 타입의 네트워크를 그대로 사용했다.

* YAML 파일 작성

```yaml
version: '3.0'
services:
  db:
    image: mysql
    environment:
      MYSQL_DATABASE: sample
      MYSQL_ROOT_PASSWORD: 1234qwer
      MYSQL_ROOT_HOST: '%'
    ports:
     - 3306:3306
  app:
    image: ssseungzz7/test:0.1
    ports:
      - 8080:8080
    command: bash
    depends_on:
      -db
```

* 처음에 위와 같이 작성 후 `docker-compose up -d`로 컨테이너를 생성했더니 `localhost:8080`에 연결이 되지 않았다. 그래서 백그라운드로 실행하지 않고 확인해 보니 처음에 `db` 컨테이너가  먼저 실행되기는 했지만 초기화가 완료되지 않은 상태였어서  ` com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure` 이 발생했다. 그래서  `app` 컨테이너가 제대로 동작하지 못했던 것이었다. 
* 이를 해결하기 위해서 [이 글](https://stackoverflow.com/questions/42567475/docker-compose-check-if-mysql-connection-is-ready)을 참고해서 MySQL이 준비될 때까지 기다리도록 했다. 

```yaml
version: '3.0'
services:
  db:
    image: mysql
    environment:
      MYSQL_DATABASE: sample
      MYSQL_ROOT_PASSWORD: 1234qwer
      MYSQL_ROOT_HOST: '%'
    ports:
     - 3306:3306
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10
  app:
    image: ssseungzz7/test:0.1
    ports:
      - 8080:8080
    command: bash
    depends_on:
      db:
        condition: service_healthy
```

* 위와 같이 수정 후에는 정상적으로 작동하는 것을 확인할 수 있었다.



##### References

[시작하세요! 도커/쿠버네티스(개정판)](http://www.yes24.com/Product/Goods/93765519)

[stackoverflow: Docker-compose check if mysql connection is ready](https://stackoverflow.com/questions/42567475/docker-compose-check-if-mysql-connection-is-ready)

[도커 컴포즈 파일 공식 문서](https://docs.docker.com/compose/compose-file/)

