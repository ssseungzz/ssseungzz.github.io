---
title: "Kotlin in Action 8장; 고차 함수: 파라미터와 반환 값으로 람다 사용"
categories:
  - Language
tags:
  - kotlin
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 8. 고차 함수: 파라미터와 반환 값으로 람다 사용

#### 8.1 고차 함수 정의

* 고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수다.
* 함수를 인자로 받는 동시에 함수를 반환하는 함수도 고차 함수다.

##### 함수 타입

* 함수 타입을 정의하려면 함수 파라미터의 타입을 괄호 안에 넣고 그 뒤에 화살표(`->`)를 추가한 다음 함수의 반환 타입을 지정하면 된다.

```kotlin
(Int, String) -> Unit
```

* 함수 타입을 선언할 때는 반환 타입을 반드시 명시해야 하므로 의미 있는 값을 반환하지 않는 경우 `Unit` 을 사용해야 한다.
* 함수 타입에서도 반환 타입을 널이 될 수 있는 타입으로 지정할 수 있다.

```kotlin
var canReturnNull: (Int, Int) -> Int? = {x, y -> null}
```

* 널이 될 수 있는 함수 타입 변수를 정의하는 경우 함수의 반환 타입이 아니라 함수 타입 전체가 널이 될 수 있는 타입임을 선언하기 위해 함수 타입을 괄호로 감싸고 그 뒤에 물음표를 붙여야만 한다.

````kotlin
var funOrNull: ((Int, Int) -> Int)? = null
````

##### 인자로 받은 함수 호출

```kotlin
fun twnAndThree(operation: (Int, Int) -> Int) {
  val result = operation(2, 3)
  println("the result is $result")
}
theAndThree { a, b -> a + b }
```

* 인자로 받은 함수를 호출하는 구문은 일반 함수를 호출하는 구문과 같다.

##### 자바에서 코틀린 함수 타입 사용

* 컴파일된 코드에서 함수 타입은 일반 인터페이스로 바뀐다. 함수 타입의 변수는 `FunctionN` 인터페이스를 구현하는 객체를 저장한다.
* 코틀린 표준 라이브러리는 함수 인자의 개수에 따라 그에 맞는 인터페이스를 제공한다.
  * 각 인터페이스에는 `invoke` 메소드 정의가 하나 들어 있고 호출하면 함수를 실행할 수 있다.
  * 함수 타입인 변수는 인자 개수에 따라 적당한 인터페이스를 구현하는 클래스의 인스턴스를 저장하며 그 클래스의 `invoke` 메소드 본문에는 람다의 본문이 들어간다.
* 자바 8 람다를 넘기면 자동으로 함수 타입의 값으로 변환되며 자바 8 이전의 자바에서는 필요한 `FunctionN` 인터페이스의 `invoke` 메소드를 구현하는 무명 클래스를 넘기면 된다.
* 자바에서 코틀린 표준 라이브러리가 제공하는 람다를 인자로 받는 확장 함수를 쉽게 호출할 수 있다.

##### 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터

* 파라미터를 함수 타입으로 선언할 때도 디폴트 값을 정할 수 있다.

```kotlin
fun <T> Collection<T>.joinToString(
				 separator: String = ", ",
         prefix: String = "",
         postfix: String = "",
         transform (T) -> String = { it.toString() } // 함수 타입 파라미터를 선언하면서 람다를 디폴트 값으로 지정
) : String {
  // ...
}
```

* 다른 디폴트 파라미터 값과 마찬가지로 함수 타입에 대한 디폴트 값 선언도 `=` 뒤에 람다를 넣으면 된다.
* 널이 될 수 있는 함수 타입을 사용할 수도 있다.
  * 이 경우 함수를 직접 호출할 수 없다. `null` 여부를 명시적으로 검사하거나 안전 호출 구문으로 처리할 수 있다. (ex - `callback?.invoke()`)

##### 함수를 함수에서 반환

* 다른 함수를 반환하는 함수를 정의하기 위해서는 함수의 반환 타입으로 함수 타입을 지정해야 한다
* 함수를 반환하려면 `return` 식에 람다나 멤버 참조나 함수 타입의 값을 계산하는 식 등을 넣으면 된다.

````kotlin
fun getShippingCostCalculator(
			delivery: Delivery): (Order) -> Double {
    if (delivery == Delivery.EXPEDITED) {
      return { order -> 6 + 2.1 * order.itemCount }
    }
    return { order -> 1.2 * order.itemCount }
}
````



#### 8.2 인라인 함수: 람다의 부가 비용 없애기

* 람다가 변수를 포획하면 람다가 생성되는 시점마다 새로운 무명클래스 객체가 생겨 클래스 생성에 따른 부가 비용이 든다.
* 반복되는 코드를 별도의 라이브러리 함수로 빼내되 컴파일러가 자바의 일반 명령문만큼 효율적인 코드를 생성하게 하기 위해 `inline` 변경자를 사용할 수 있다.
  * 컴파일러는 `inline` 이 붙은 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해 준다.

##### 인라이닝이 작동하는 방식

* 어떤 함수를 `inline` 으로 선언하면 그 함수의 본문이 인라인된다.
  * 함수를 호출하는 코드를 함수를 호출하는 바이트코드 대신 함수 본문을 번역한 바이트코드로 컴파일한다.
* 람다의 본문에 의해 만들어지는 바이트코드는 그 람다를 호출하는 코드 정의의 일부분으로 간주되기 때문에 코틀린 컴파일러는 그 람다를 함수 인터페이스를 구현하는 무명 클래스로 감싸지 않는다.
* 인라인 함수를 호출하면서 함수 타입의 변수를 넘기는 경우 인라인 함수를 호출하는 코드 위치에서는 변수에 저장된 람다의 코드를 알 수 없어 람다 본문은 인라이닝되지 않고, 따라서 람다는 일반적인 경우와 마찬가지로 호출된다.

##### 인라인 함수의 한계

* 람다를 사용하는 모든 함수를 인라이닝할 수는 없다.
* 함수 본문에서 파라미터로 받은 람다를 호출한다면 호출을 쉽게 람다 본문으로 바꿀 수 있다. 
  * 하지만 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 람다를 표현하는 객체가 어딘가에는 존재해야 하기 때문에 람다를 인라이닝할 수 없다.
* 어떤 람다에 너무 많은 코드가 들어가거나 인라이닝을 하면 안 되는 코드가 들어갈 가능성이 있다면 그런 람다를 인라이닝하면 안 된다.
  * 이런 식으로 인라이닝하면 안 되는 람다를 파라미터로 받는다면 `noinline` 변경자를 파라미터 이름 앞에 붙여서 인라이닝을 금지할 수 있다.

##### 컬렉션 연산 인라이닝

* 코틀린의 `filter, map` 등의 함수는 인라인 함수이다.
* 처리할 원소가 많아지만 중간 리스트를 사용하는 부가 비용도 커진다.
  * `asSequence` 를 통해 리스트 대신 시퀀스를 사용하면 중간 리스트로 인한 부가 비용은 줄어든다. 이때, 각 중간 시퀀스는 람다를 필드에 저장하면 객체로 표현되며 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출한다.
  * 따라서 시퀀스는 람다를 저장해야 하므로 람다를 인라인하지 않는다. 그렇기 때문에 지연 계산을 통해 성능을 향상시키려는 이유로 모든 컬렉션 연산에 `asSequence` 를 붙여서는 안 된다.
  * 시퀀스 연산에서는 람다가 인라이닝되지 않기 때문에 크기가 작은 컬렉션은 오히려 일반 컬렉션 연산이 더 성능이 나을 수도 있다. 시퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우뿐이다.

##### 함수를 인라인으로 선언해야 하는 경우

* 일반 함수 호출의 경우 JVM은 인라이닝을 강력하게 지원한다.
  * 바이트코드를 실제 기계어 코드로 번역하는 과정(JIT)에서 일어난다. 바이트코드에서는 함수 구현이 한 번만 있으면 되고, 그 함수를 호출하는 부분에서 함수 코드를 중복할 필요가 없다.
* 코틀린 인라인 함수는 바이트코드에서 호출 지점을 함수 본문으로 대치하기 때문에 코드 중복이 생긴다.
  * 반면 람다를 인자로 받는 함수를 인라이닝하면 함수 호출 비용을 줄이고 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요가 없어지므로 이익이 더 많다.
  * 인라이닝하는 함수가 큰 경우 함수의 본문에 해당하는 바이트코드를 모든 호출 지점에 넣으면 바이트코드가 커질 수 있다.

##### 자원 관리를 위해 인라인된 람다 사용

* 코틀린에서는 자바의 `try-with-resource` 와 같은 기능을 제공하는 `use` 함수가 표준 라이브러리에 있다.
  * 람다 본문 안에서 사용한 `return` 은 넌로컬이다.

```kotlin
fun readFirstLineFromFile(path:String): String {
  BufferedReader(FileReader(path)).use { // use 함수를 호출하면서 파일에 대한 연산을 실행할 람다를 넘긴다
    br -> return br.readLine() // 자원에서 맨 처음 가져온 한 줄을 람다가 아닌 readFirstLineFromFile에서 반환한다 
  } 
}
```



#### 고차 함수 안에서 흐름 제어

##### 람다 안의 return문: 람다를 둘러싼 함수로부터 반환

* 람다 안에서 `return` 을 사용하면 람다로부터만 반환되는 게 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환된다.
  * 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 `return` 문을 넌로컬(`non-local`) `return` 이라 부른다.
* 코틀린에서는 람다를 받는 함수로 `for`나 `synchronized` 와 같은 기능을 구현한다. 그런 함수 안에서 쓰이는 `return` 이 자바와 같은 의미를 갖게 허용한다.
* 이렇게 `return` 이 바깥쪽 함수를 반환시킬 수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우뿐이다.
* 인라이닝되지 않는 함수에 전달되는 람다 안에서 `return` 을 사용할 수는 없다.

##### 람다로부터 반환: 레이블을 사용한 return

* 람다 식에서도 로컬(`local`) `return` 을 사용할 수 있다.
  * 람다 안에서 로컬 `return` 은 `for` 루프의 `break`와 비슷한 역할을 한다.
  * 로컬 `return` 은 실행으 ㄹ끝내고 람다를 호출했던 코드의 실행을 계속 이어간다.
* 로컬와 넌로컬을 구분하기 위해 레이블을 사용해야 한다.
  *  `return` 으로 실행을 끝내고 싶은 람다 식 앞에 레이블을 붙이고, `return` 키워드 뒤에 그 레이블을 추가하면 된다.

```kotlin
for lookForAlice(people: List<Person>) {
  people.forEach label@{ // 람다 식 앞에 레이블을 붙인다
    if (it.name == "Alice") return@label // return@label은 앞에서 정의한 레이블을 참조한다
  }
  println("Alice might be somewhere") // 항상 이 줄이 출력된다
}
```

* 람다 식의 레이블을 명시하면 함수 이름을 레이블로 사용할 수 없다.
* 람다 식에는 레이블이 2개 이상 붙을 수 없다.

##### 무명 함수: 기본적으로 로컬 return

* 무명 함수는 코드 블록을 함수에 넘길 때 사용할 수 있는 다른 방법이다.
  * 일반 함수와 비슷하지만 함수 이름이나 파라미터 타입을 생략할 수 있다.

```kotlin
for lookForAlice(people: List<Person>) {
  people.forEach(fun (person) { // 람다 식 대신 무명 함수를 사용한다
    if (it.name == "Alice") return // return은 가장 가까운 함수를 가리키는데 이 위치에서 가장 가까운 함수는 무명 함수다
    println("${person.name} is not Alice")
  })
}
```

* 무명 함수 안에서 레이블이 붙지 않은 `return` 식은 무명 함수 자체를 반환시킬 뿐 무명 함수를 둘러싼 다른 함수를 반환시키지 않는다.
* `return` 은 `fun` 키워드를 사용해 정의된 가장 안쪽 함수를 반환시키므로 람다 본문의 `return`  은 (`fun` 을 사용해 정의되지 않기 때문에) 람다 밖의 함수를 반환시키며, 무명 함수는 그 함수 자신이 바로 가장 안쪽에 있는 `fun` 으로 정의된 함수다.
