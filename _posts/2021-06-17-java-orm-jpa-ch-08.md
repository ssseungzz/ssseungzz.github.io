---
title: "JPA 뽀개기 - 프록시와 연관관계 관리"
categories:
  - Develop
tags:
  - jpa
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 8. 프록시와 연관관계 관리

#### 프록시

* 엔티티를 조회할 때 항상 연관된 엔티티들을 사용하는 것은 아니다. 이런 경우에까지 연관된 엔티티를 함께 조회하는 것은 효율적이지 못하다.

* JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 떄까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이를 **지연 로딩**이라고 한다.

* 값을 실제 사용하는 시점에 데이터베이스에서 팀 엔티티에 필요한 데이터를 조회한다.

* 지연 로딩을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이를 프록시 객체라 한다.

  > JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임했다.

##### 프록시 기초

* 엔티티를 실제 사용하느 시점까지 데이터베이스 조회를 미루고 싶으면 `EntityManager.getReference()` 메소드를 사용하면 된다.

  * 이 메소드를 호출하면 데이터베이스 접근을 위임한 프록시 객체를 반환한다.

* 프록시의 특징

  * 프록시 클래스는 *실제 클래스를 상속*받아 만들어지므로 실제 클래스와 겉 모양이 같다.
  * 프록시 객체는 실제 객체에 대한 참조를 보관한다. 그리고 프록시 객체의 메소드를 호추하면 프록시 객체는 실제 객체의 메소드를 호출한다.
  * 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
  * 프록시 객체를 초기화한다고 해서 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
  * 프록시 객체는 원본 엔티티를 상속받은 객체이므로 **타입 체크** 시에 주의해야 한다.
  * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 `getReference`를 호출해도 실제 엔티티를 반환한다.
  * 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 준영속 상태의 프록시를 초기화하면 구현체에 따라 예외가 발생할 수 있다.

* 프록시 객체의 초기화

  * 프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라고 한다.

  1. 프록시 객체에 메소드를 호출해서 실제 데이터를 조회한다.
  2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 **실제 엔티티 생성을 요청**하는데 이것을 초기화라 한다.
  3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
  4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 멤버 변수에 보관한다.
  5. 프록시 객체는 실제 객체의 메소드를 호출해서 결과를 반환한다.

##### 프록시와 식별자

* 엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.
  * 따라서 식별자 값을 조회하는 메소드를 호출하는 경우 프록시를 초기화하지 않는다.
  * 접근 방식을 프로퍼티로 설정한 경우에만 초기화하지 않는다.
* 엔티티 접근 방식을 필드로 설정하면 JPA는 `getId`가 id만 조회하는 메소드인지 다른 필드까지 활용해서 어떤 일을 하는 메소드인지 알지 못하므로 프록시 객체를 초기과한다.
* 연관관계를 설정할 때는 식별자 값만 사요하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있다.

##### 프록시 확인

* JPA가 제공하는 `PersistenceUnitUtil.isLoaded(Object entiry)` 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.
* 조회한 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면 클래스 명을 직접 출력해 보면 된다.
  * 프록시를 생성하는 라이브러리에 따라 차이가 있으나 클래스 명 뒤에 부가적인 표시가 붙으면 프록시 객체이다.



#### 즉시 로딩과 지연 로딩

* JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 즉시 로딩과 지연 로딩 방법을 제공한다.

##### 즉시 로딩

* 즉시 로딩(`EAGER LOADING`)을 사용하려면 `@ManyToOne`의 `fetch` 속성을 `FetchType.EAGER`로 지정한다.
* 대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.
  * JPA는 외래 키가 `null`인 상황에 대비하기 위해 기본적으로 외부 조인을 사용한다.
  * 내부 조인이 성능과 최적화에서 더 유리하므로 외래 키에 `NOT NULL` 제약 조건을 설정하면 외부 조인 대신 내부 조인을 사용한다.

##### 지연 로딩

* 지연 로딩(`LAZY LOADING`)을 사용하려면 `@ManyToOne`의 `fetch` 속성을 `FetchType.LAZY`로 지정한다.
  * 연관된 엔티티를 프록시 객체로 설정한다. 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 실제 필요한 순간이 되어서야 데이터베이스를 조회해 프록시 객체를 초기화한다.
  * 그러나 조회 대상이 영속성 컨텍스트에 이미 있으먄 프록시 객체를 사용할 이유가 없으므로 실제 객체를 사용한다.



#### 지연 로딩 활용

* 자주 함께 사용되는 엔티티인지에 따라 즉시 로딩, 지연 로딩을 설정해 활용할 수 있다.

##### 프록시와 컬렉션 래퍼

* 하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이를 컬렉션 래퍼라고 한다.

* 엔티티를 지연 로딩하면 컬렉션의 경우 컬렉션 래퍼가 지연 로딩을 처리한다.

  * 컬렉션 래퍼도 컬렉션에 대한 프록시 역할을 수행한다.

  * 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다.

##### JPA 기본 페치 전략

* 엔관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다.
* 모든 연관관계에 지연 로딩을 사용하고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하는 게 낫다.

##### 컬렉션에 `FetchType.EAGER` 사용 시 주의점

* 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.
  * 컬렉션과 조인한다는 것은 데이터베이스 테이블로 보면 일대다 조인이다. 일대다 조인은 결과 데이터가 다쪽에 있는 수만큼 증가하게 된다. 이렇게 되면 너무 많은 데이터를 반환해 애플리케이션 성능이 저하될 수 있다.
  * 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. 일대다 관계를 즉시 로딩 시에 내부 조인을 사용하면 다쪽에 연관된 엔티티가 없는 일쪽의 엔티티를 가져오지 못할 수 있기 때문이다.
* `@ManyToOne`, `@OneToOne`
  * `(optional = false)`: 내부 조인
  * `(optional = true)`: 외부 조인
* `@OneToMany`, `@ManyToMany`
  * `(optional = false)`: 외부 조인 
  * `(optional = true)`: 외부 조인



#### 영속성 전이: CASCADE

* 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 영속 상태로 만들고 싶은 경우 영속성 전이(*transitive persistence*) 기능을 사용한다.
  * JPA는 `CASCADE` 옵션으로 영속성 전이를 제공한다.
* JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다. 따라서 엔티티를 영속 상태로 만들고 그와 연관관계를 설정한 엔티티도 각각 영속 상태로 만든다.

##### 영속성 전이: 저장

* 영속성 전이를 활성화하는 `CASCADE` 옵션은 아래와 같이 사용 가능하다.
  * `@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)`
  * 옵션이 적용된 엔티티도 함께 영속화된다.
  * 연관관계를 매핑하는 것과는 관련이 없고 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함만을 제공한다.

##### 영속성 전이: 삭제

* 영속성 전이는 `CascadeType.REMOVE`로 설정하면 엔티티 삭제 시 연관된 엔티티도 함께 삭제한다.
  * 삭제 순서는 외래 키 제약 조건을 고려해서 연관된 엔티티부터 삭제한다.

##### CASCADE의 종류

* 다양한 옵션이 있으며 여러 속성을 함께 사용 가능하다.

````java
public enum CascadeType {
  ALL, // 모두 적용
  PERSIST, // 영속
  MERGE, // 병합
  REMOVE, //삭제
  REFRESH,
  DETACH
}
````

* `PERSIST`와 `REMOVE`의 경우 `em.persist()`, `em.remove()`를 실행할 때 전이가 발생하지 않고 플러시를 호출할 때 전이가 발생한다.



#### 고아 객체

* JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이를 고아 객체 제거라고 한다.
* 연관관계로 맺어진 컬렉션에 `orphanRemoval = true` 옵션을 적용하면 컬렉션에서 제거한 엔티티는 자동으로 작세된다.
  * 컬렉션에서 엔티티를 제거하면 데이터베이서의 데이터도 삭제된다.
  * 영속성 컨텍스트를 플러시할 때 적용되므로 플러시 시점에 DELETE SQL이 실행된다.
* 고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.
  * 따라서 참조하는 곳이 하나일 때만 사용해야 한다.
  * 이런 이유로 `orphanRemoval`은 `@OneToOne`, `@OneToMany`에만 사용할 수 있다.



#### 영속성 전이 + 고아 객체, 생명 주기

* `CasCadeType.ALL` + `orphanRemoval`을 동시에 사용하면 부모 엔티티를 통해 자식의 생명주기를 관리할 수 있다. 자식을 저장하려면 부모에 등록하고, 자식을 삭제하려면 부모에서 제거하면 된다.
  * 일반적으로는 `persist`를 통해 영속화하고 `remove`를 통해 제거된다. 즉, 엔티티 스스로 생명주기를 관리한다.