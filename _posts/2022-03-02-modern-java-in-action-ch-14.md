---
title: "Modern Java in Action 14장; 자바 모듈 시스템"
categories:
  - Language
tags:
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 14. 자바 모듈 시스템
#### 14.1 압력: 소프트웨어 유추
* 모듈 시스템은 어떤 문제를 해결할 수 있을까? 궁극적으로 소프트웨어 아키텍처 수준에서는 기반 코드를 바꿔야 할 때 유추하기 쉬우므로 생산성을 높일 수 있는 소프트웨어 프로젝트가 필요하다.
  * 추론하기 쉬운 소프트웨어를 만드는 데에 도움을 주는 관심사 분리와 정보 은닉이 있다.

##### 14.1.1 관심사 분리
* 관심사 분리(SoC, Separation of concerns)는 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다.
* 기능을 모듈이라는 각각의 부분 즉, 서로 겹치지 않는 코드 그룹으로 분리할 수 있다.
  * 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여 줄 수 있다.
* SoC 원칙은 모델, 뷰, 컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다. SoC 원칙은 다음과 같은 장점을 제공한다.
  * 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다.
  * 개별 부분을 재사용하기 쉽다.
  * 전체 시스템을 쉽게 유지보수할 수 있다.

##### 14.1.2 정보 은닉
* 정보 은닉은 세부 구현을 숨기도록 장려하는 원칙이다.
* 세부 구현을 숨김으로써 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다. 즉, 코드를 관리하고 보호하는 데에 유용한 원칙이다.
* 캡슐화는 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미한다.
  * 캡슐화된 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성이 줄어든다.

##### 14.1.3 자바 소프트웨어
* 잘 설계된 소프트웨어를 만들려면 이 두 가지 원칙을 따라야 한다.
* 특정 문제와 관련된 패키지, 클래스, 인터페이스를 그룹으로 만들어 코드를 그룹화할 수 있다.
* 접근 제한자와 패키지 수준 접근 권한 등을 이용해 메서드, 필드 클래스의 접근을 제어했지만 이런 방식으로는 원하는 접근 제한을 달성하기 어렵다.

#### 14.2 자바 모듈 시스템을 설계한 이유
##### 14.2.1 모듈화의 한계
###### 제한된 가시성 제어
* 패키지의 가시성 제어 기능은 유명무실한 수준으로 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 `public`으로 선언해 모두에게 공개해야 한다.
* 보안 측면에서 볼 때 코드가 노출되었으므로 코드를 임의로 조작하는 위협에 더 많이 노출될 수 있다.

###### 클래스 경로
* 자바는 클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다.
* 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없어 클래스 경로에 두 가지 버전의 같은 라이브러리가 존재할 때 어떤 일이 발생할지 예측 불가하다.
* 클래스 경로는 명시적인 의존성을 지원하지 않는다. 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않는다.
  * 빠진 게 있거나 충돌이 있는지 알기 어렵다.
  * 메이븐이나 그레이들 같은 빌드 도구는 이런 문제를 해결하는 데에 도움을 준다.

##### 14.2.2 거대한 JDK
* 자바 개발 키트(JDK)는 자바 프로그램을 만들고 실행하는 데에 도움을 주는 도구의 집합으로 자바 프로그램을 컴파일하는 javac, 자바 애플리케이션을 로드하고 실행하는 java, 입출력을 포함해 런타임 지원을 제공하는 JDK 라이브러리, 컬렉션, 스트림 등이 있다.
* 자바 8에서는 컴팩트 프로파일이라는 지법으로 관련 분야에 따라 JDK 라이브러리가 세 가지 프로파일로 나뉘어 각각 다른 메모리 풋프린트를 제공하는 임의적인 방식으로 JDK 전부를 필요로 하지 않는 경우의 문제를 해결하려 했다.
* JDK 라이브러리의 많은 내부 API는 공개되지 않아야 하지만 낮은 캡슐화 지원 때문에 공개되었다.
  * JDK 내부에서만 사용하도록 만든 클래스가 여러 라이브러리에서 사용되면서 호환성을 깨지 않고 관련 API를 바꾸기가 어려워졌다.
* 이런 문제들 때문에 JDK 자체도 모듈화할 수 있는 자바 모듈 시스템 설계의 필요성이 제기되었다.
  * JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며 플랫폼을 진화시킬 수 있는 캡슐화를 제공할 구조가 필요했다.


#### 14.3 자바 모듈: 큰 그림
* 자바 8은 모듈이라는 새로운 자바 프로그램 구조 단위를 제공한다.
* 모듈은 `module`이라는 새 키워드에 이름과 바디를 추가해서 정의한다.
  * 모듈 디스크립터는 `module-info.java` 라는 특별한 파일에 저장된다.
  * 모듈 디스크립터는 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다.
![](https://user-images.githubusercontent.com/55083845/157044566-b402d423-b20b-464a-b080-00408e47f297.jpeg)
* `exports`는 퍼즐에서 돌출부, `requires`는 패인 부분으로 생각할 수 있다.

#### 14.4 자바 모듈 시스템으로 애플리케이션 개발하기
##### 14.4.1 애플리케이션 셋업
* 애플리케이션이 처리할 여러 작업에 따라 애플리케이션의 개념을 모델링할 여러 클래스와 인터페이스를 정의해야 한다.
* 자바 모듈 시스템으로 프로젝트를 모듈화하기 위해 프로젝트를 분리할 수 있는 여러 기능(관심사)으로 쪼갠다.
  * 다양한 소스에서 데이터를 읽음
  * 다양한 포맷으로 구성된 데이터를 파싱
  * 도메인 객체를 구체화
  * 통계 계산 및 반환
  * 다양한 기능을 분리 조정
* 세부적으로 문제를 나누어 많은 내부 구현이 추가되었을 때 캡슐화와 추론의 장점을 누릴 수 있다. 아래 나열한 목록을 애플리케이션 경계에 의존하는 패키지 목록으로 생각할 수 있다. 
  * 각 모듈은 다른 모듈로 노출하고 싶지 않은 내부 구현을 포함할 것이다.
  * `expenses.readers`
  * `expenses.readers.http`
  * `expenses.readers.file`
  * `expenses.parsers`
  * `expenses.readers.json`
  * `expenses.model`
  * `expenses.statistics`
  * `expenses.application`

##### 14.4.2 세부적인 모듈화와 거친 모듈화
* 세부적인 모듈화 기법 대부분은 위처럼 모든 패키지가 자신의 모듈을 갖는다.
* 거친 모듈화 기법 대부분은 한 모듈이 시스템의 모든 패키지를 포함한다.
* 세부적인 모듈화는 이득에 비해 설계 비용이 증가하는 반면 거친 모듈화는 모듈화의 장점을 잃는다.
* 따라서 프로젝트가 이해하기 쉽고 고치기 쉬운 수준으로 적절하게 모듈화되어 있는지 주기적으로 확인하는 프로세스를 갖는 게 좋다.

##### 14.4.3 자바 모듈 시스템 기초
```text
expenses.application
  module-info.java
  com
    example
      expenses
       application
         ExpensesApplication.java
```
```java
module expenses.application { // module-info.java

}
```
```
javac module-info.java com/example/expenses/application/ExpensesApplication.java -d target
```
* `java` 프로그램으로 자바 `.class` 파일을 실행할 때 다음과 같은 두 가지 옵션이 새로 추가되었다.
  * `--module-path`: 어떤 모듈을 로드할 수 있는지 지정한다. 이 옵션은 클래스 파일을 지정하는 `--classpath` 인수와는 다르다.
  * `--module`: 이 옵션은 실행할 메인 모듈과 클래스를 지정한다.


#### 14.5 여러 모듈 활용하기
##### 14.5.1 exports 구문
```java
module expenses.readers {
  exports com.example.expenses.readers; // 패키지명
  exports com.example.expenses.readers.file; // 패키지명
  exports com.example.expenses.readers.http; // 패키지명
}
```
* `exports`는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다. 기본적으로 모듈 내의 모든 것은 캡슐화된다.
* 모듈 시스템은 화이트리스트 기법을 통해 캡슐화를 제공하므로 다른 모듈에서 사용할 수 있는 기능이 무엇인지 명시적으로 결정해야 한다.

##### 14.5.2 requires 구문
```java
module expenses.readers {
  requires java.base; // 모듈명

  exports com.example.expenses.readers; // 패키지명
  exports com.example.expenses.readers.file; // 패키지명
  exports com.example.expenses.readers.http; // 패키지명
}
```
* `requires`는 의존하고 있는 모듈을 지정한다.
* 기본적으로 모든 모듈은 `java.base`라는 플랫폼 모듈에 의존하는데 이 모듈은 자바 메인 패키지를 포함한다. 항상 기본적으로 필요한 모듈이므로 명시적으로 정의할 필요는 없다.
* 이외의 모듈을 임포트할 때 `requires`를 사용한다.

##### 14.5.3 이름 정하기
* 오라클은패키지명처럼 인터넷 도메인명을 역순으로 모듈의 이름을 정하도록 권고한다.
* 모듈명은 노출된 주요 API 패키지와 이름이 같아야 한다는 규칙도 있다.

#### 14.6 컴파일과 패키징
* 각 모듈에 `pom.xml` 파일을 추가한다. 
  * 각 모듈은 독립적으로 컴파일되므로 자체적으로 각각이 한 개의 프로젝트다.
  * 전체 프로젝트 빌드를 조정할 수 있도록 모든 모듈의 부모 모듈에도 `pom.xml`을 추가한다.
* 모듈 디스크립터(`module-info.java`)는 `src/main/java` 디렉터리에 위치해야 한다.
  * 올바른 모듈 소스 경로를 이용하도록 메이븐이 `javac`를 설정한다.
* 순조롭게 빌드될 수 있도록 명시적으로 부모 모듈을 `<parent>`로 지정한다.
* 다른 모듈에 의존하는 모듈의 경우 의존성에 해당 모듈을 추가한다.
* 빌드 과정을 가이드할 전역 `pom.xml`을 작성한다.
  * 메이븐은 `<module>`을 가진 여러 메이븐 모듈을 가진 프로젝트를 지원한다.
  * 사용하는 모듈을 해당 태그로 추가한다.
  * `mvn clean package` 명령을 실행해 프로젝트의 모듈을 JAR로 만들 수 있다.
  * 이 명령을 실행하면 각각의 모듈들을 JAR로 만들 수 있으며 만들어진 JAR들을 모듈 경로에 포함해서 모듈 애플리케이션을 실행할 수 있다.

#### 14.7 자동 모듈
* `module-info.java`에 `requires` 구문으로 라이브러리를 추가하고, `pom.xml`에 의존성을 추가한 뒤 패키징 명령을 실행하면 프로젝트가 빌드된다.
* 모듈화되어 있지 않은 라이브러리의 경우 자바는 JAR를 자동 모듈이라는 형태로 적절하게 변환한다.
  * 모듈 경로상에 있으나 `module-info` 파일을 가지지 않은 모든 JAR는 자동 모듈이 된다.
  * 자동 모듈은 암묵적으로 자신의 모든 패키지를 노출시키며 자동 모듈의 이름은 JAR 이름을 이용해 정해진다.

#### 14.8 모듈 정의와 구문들
* `module` 지시어를 이용해 모듈을 정의할 수 있다.

##### 14.8.1 requires
* 컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의존함을 정의한다.
  * **모듈명**을 인수로 받는다.

##### 14.8.2 exports
* 지정한 패키지를 다른 모듈에서 이용할 수 있도록 공개 형식으로 만든다.
  * **패키지명**을 인수로 받는다.

##### 14.8.3 requires transitive
* 다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정할 수 있다.
* 필요로 하는 모듈이 다른 모듈의 형식을 반환하는 상황에서 전이성 선언을 유용하게 사용할 수 있다.

##### 14.8.4 exports to
* 사용자에게 공개할 기능을 제한할 수 있다.

##### 14.8.5 open과 opens
* 모듈 선언에 이용하면 모든 패키지를 다른 모듈에 반사적으로 접근을 허용할 수 있다.
* 자바 9 이전에는 리플렉션으로 객체의 비공개 상태를 확인할 수 있었지만 자바 9에서는 기본적으로 리플렉션이 이런 기능을 허용하지 않는다. 이 기능이 필요할 경우 `open` 구문을 명시적으로 사용해야 한다.
* `to`를 붙여 특정 모듈에만 허용할 수도 있다.

##### 14.8.6 uses와 provides
* `provides` 구문으로 서비스 제공자를 `uses` 구문으로 서비스 소비자를 지정할 수 있다.
