---
title: "2024 년 3 월 9 일 TIL"
categories:
  - TIL
tags:
toc: true
toc_label: "Contents"
toc_sticky: true

---

#### 오늘 한 일

* 이펙티브 자바 아이템 79(과도한 동기화는 피하라) 읽기
  * 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다. (동기화된 영역 안에서는 재정의할 수 있는 메서드 호출 X, 클라이언트가 넘겨준 함수 객체 호출 X) 외부의 함수가 호출되는 상황은 동기화 블록 바깥으로 옮기자. 혹은 동시성 컬렉션 라이브러리의 클래스를 사용할 수도 있다.
  * 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다. 동기화가 초래하는 비용은 락을 얻는 데에 드는 CPU 시간보다 경쟁하느라 낭비하는 시간이다. 또한 가상머신의 코드 최적화를 제한하기도 한다.
  * 가변 클래스를 작성하려거든 동기화를 전혀 하지 말고 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하고, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자. 단, 클라이언트가 외부 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 두 번째 방법을 선택하는 것이 좋다. (첫 번째는 `java.util`, 두 번째는 `java.util.concurrent`) 
  * 클래스를 내부에서 동기화하기로 했다면 락 분할, 락 스트라이핑, 비차단 동시성 제어 등의 기법을 동원해 동시성을 높여 줄 수 있다.
    * 락 분할: 하나의 클래스에서 기능적으로 락을 분리해서 사용하기
    * 락 스트라이핑: 구조적으로 하나의 자료구조를 나눠서 라킹
    * 비차단 동시성 제어: 비차단 메서드(호출되는 함수가 바로 리턴해서 호출한 함수에게 제어권 전달) 호출 후 바로 반환받아 다른 작업을 할 수 있게 되지만 메서드 호출에 의해 수행되는 작업이 완료되는 것은 아니며, 호출하는 메서드가 호출되는 메서드 쪽에 작업 완료 여부를 계속 문의하는 방식(참고: https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/) 

  




#### 느낀 점

* 동기화, 동시성, 블록-논볼록 이런 거 언제쯤 머리 안 아플까.......