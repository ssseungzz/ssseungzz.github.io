---
title: "JPA 뽀개기 - 값 타입"
categories:
  - Develop
tags:
  - jpa
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 9. 값 타입

* JPA의 데이터 타입을 크게 분류하면 엔티티 타입과 값 타입으로 나눌 수 있다.
  * 엔티티 타입은 `@Entity`로 정의하는 객체
  * 값 타입은 `int`, `Integer`, `String`처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
* 엔티티 타입은 식별자를 통해 추적할 수 있지만 값 타입은 식별자가 없고 숫자나 문자 같은 속성만 있으므로 추적할 수 없다.
* 값 타입은 세 가지로 나눌 수 있다.
  * 기본값 타입: 자바 기본 타입, 래퍼 클래스, `String`
  * 임베디드 타입
  * 컬렉션 값 타입



#### 기본값 타입

* `String`, `int` 등
* 값 타입은 공유하면 안 된다.
  * 자바에서 기본 타입은 절대 공유되지 않는다.



#### 임베디드 타입(복합 값 타입)

* 새로운 값 타입을 직접 정의해서 쓸 수 있는데 JPA에서는 이를 임베디드 타입이라고 한다.
* 직접 정의한 임베디드 타입도 `int`, `String`처럼 값 타입이다.
* `@Embeddedable`는 값 타입을 정의하는 곳에 사용한다.
  * 재사용할 수 있고 응집도가 높아진다.
  * 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있다.
* `@Embedded`는 값 타입을 사용하는 곳에 표시한다.
* 임베디드 타입은 기본 생성자가 필수이다.
* 임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하므로 엔티티와 임베디드 타입은 컴포지션 관계가 된다.

##### 임베디드 타입과 테이블 매핑

* 임베디드 타입은 엔티티의 값일 뿐이므로 값이 속한 엔티티의 테이블에 매핑한다.
* 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.

##### 임베디드 타입과 연관관계

* 임베디드 타입은 값 타입을 포함하거나 엔티티를 참조할 수 있다.

##### `@AttributeOverried`: 속성 재정의

* 임베디드 타입에 정의한 매핑 정보를 재정의하려면 엔티티에 `@AttiributeOverride`를 사용하면 된다.

##### 임베디드 타입과 null

* 임베디드 타입이 `null`이면 매핑한 컬럼 값은 모두 `null`이 된다.



#### 값 타입과 불변 객체

##### 값 타입 공유 참조

* 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다.
  * 같은 인스턴스를 참조해서 한 엔티티에서 바꾸면 다른 엔티티도 바뀌기 때문이다.
  * 이러한 부작용을 막으려면 값을 복사해서 사용하면 된다.

##### 값 타입 복사

* 값을 복사해서 돌려주는 메소드를 만들어 사용할 수 있다.
* 그런데 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.
  * 자바는 기본 타입에 값을 대입하면 값을 복사해서 전달한다.
  * 객체에 값을 대입하면 항상 참조 값을 전달한다.
* 객체를 대입할 때마다 인스턴스를 복하새어 대입하면 공유 참조를 피할 수 있지만 복사하지 않고 원본의 참조 값을 직접 넘기는 값을 막을 방법이 없다.
  * 자바는 대입하려는 것이 값 타입인지 아닌지에 상관없이 기본 타입이면 값을 복사해서 넘기고 객체면 참조를 넘긴다.
  * 객체의 공유 참조는 피할 수 없다.
  * 근본적인 해결책의 가장 단순한 방법으로는 객체의 값을 수정하지 못하도록 수정자를 모두 제거하는 방법이 있다.

##### 불변 객체

* 객체를 불변하게 만들려면 값을 수정할 수 없으므로 부작용을 차단할 수 있다.

* 따라서 **값 타입은 불변 객체로 설계해야** 한다.

  * 불변 객체의 값은 조회할 수 있지만 수정할 수 없다.
  * 객체이기 때문에 인스턴스의 참조 값 공유를 피할 수는 없지만 참조 값을 공유해도 인스턴스의 값을 수정할 수 없으므로 부작용이 발생하지 않는다.

* 불변 객체를 구현하는 가장 간단한 방법은 생성자로만 값을 설정하고 수정자를 만들지 않으면 된다.

  * 만약 값을 수정해야 하면 새로운 객체를 생성해서 사용해야 한다.

  > `Integer`, `String`은 자바가 제공하는 대표적인 불변 객체이다.



#### 값 타입의 비교

* 값 타입은 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 한다.
* 따라서 값 타입을 사용할 때는 `equals`를 사용해서 동등성 비교를 해야 한다. 
  * 재정의할 때는 보통 모든 필드의 값을 비교하도록 구현한다.



#### 값 타입 컬렉션

* 값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 `@ElementCollection`, `@CollectionTable` 어노테이션을 사용하면 된다.
* 관계형 데이터베이스의 테이블은 컬럼 안에 컬렉션을 포함할 수 없으므로 별도의 테이블을 추가하고 `@CollectionTable`을 사용해서 추가한 테이플을 매핑해야 한다.
  * 값으로 사용되는 컬럼이 하나면 `@Column`을 사용해서 컬럼명을 지정할 수 있다.
  * 테이플 매핑 정보는 `@AttributeOverride`를 통해서 재정의할 수 있다.

##### 값 타입 컬렉션 사용

* 값 타입 컬렉션의 경우 저장될 때 컬렉션의 각각의 값에 대해 INSERT SQL이 실행된다.
  * 영속성 컨텍스트를 플러시할 때 SQL을 전달한다.
  * 영속성 전이 + 고아 객체 기능을 필수로 가진다.
  * 값 타입 컬렉션도 조회할 때 페치 전략을 선택할 수 있는데 LAZY가 기본이다.
* 값 타입 컬렉션을 수정
  * 임베디드 값 타입의 경우 테이블만 UPDATE 한다. 즉, 엔티티를 수정하는 것과 같다.
  * 기본 값 타입의 경우 수정 전 값을 제거하고 수정 후 값을 추가한다.
  * 값 타입은 불변해야 하므로 임베디드 값 타입 컬렉션 수정 시 기존 것을 삭제하고 새 것을 등록한다.

##### 값 타입 컬렉션의 제약 사항

* 값 타입은 식별자 개념이 없고 단순한 값들의 모임이므로 값을 변경해 버리면 데이터베이스에 저장된 원본 데이터를 찾기는 어렵다.
* 특정 엔티티 하나에 소속된 값 타입은 값이 변경되어도 자신이 소속된 엔티티를 데이터베이스에서 찾고 값을 변경하면 된다.
  * 값 타입 컬렉션의 경우 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관된다. 따라서 여기에 보관된 값 타입의 값이 변경되면 데이터베이스에 있는 원본 데이터를 찾기 어렵다는 문제가 있다.
  * 이런 문제로 인해 JPA 구현체들은 값 타입 컬렉션에 변경 사항이 발생하면 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제하고 현재 값 타입 컬렉션에 있는 모든 값을 데이터베이스에 다시 저장한다.
  * 따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신 일대다 관계를 고려해야 한다.
* 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 한다.
  * 데이터베이스 기본 키 제약 조건으로 인해 컬럼에 `null`을 입력할 수 없고 같은 값을 중복해서 저장할 수 없는 제약도 있다.
* 이러한 문제를 해결하려면 새로운 엔티티를 만들어 일대다 관계로 설정하면 된다.
  * 여기에 영속성 전이 + 고아 객체 제거 기능을 적용하면 값 타입 컬렉션처럼 사용할 수 있다.