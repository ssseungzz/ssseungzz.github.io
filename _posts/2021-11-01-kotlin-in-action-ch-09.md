---
title: "Kotlin in Action 9장; 제네릭스"
categories:
  - Language
tags:
  - kotlin
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 9. 제네릭스

#### 9.1 제네릭 타입 파라미터

* 타입을 컴파일러가 추론할 수 있을 경우 타입 인자를 명시할 필요가 없지만, 빈 리스트를 만들어야 하는 경우 등 타입 인자를 추론할 근거가 없으므로 직접 타입 인자를 명시해야 한다.

##### 제네릭 함수와 프로퍼티

* 제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.
* 클래스나 인터페이스 안에 정의된 메소드, 확장 함수 또는 최상위 함수에서 타입 파라미터를 선언할 수 있다.
  * 확장 함수에서는 수신 객체나 파라미터 타입에 타입 파라미터를 사용할 수 있다.
* 제네릭 함수를 정의할 때와 마찬가지로 제네릭 확장 프로퍼티를 선언할 수 있다.

```kotlin
val <T> List<T>.penultimate: T // 모든 리스트 타입에 이 제네릭 확장 프로퍼티를 사용할 수 있다.
   get() = this[size - 2]
```

##### 제네릭 클래스 선언

* 타입 파라미터를 넣은 꺾쇠 기호를 클래스 이름 뒤에 붙이면 클래스를 제네릭하게 만들 수 있다.
* 제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 대해 타입 인자를 지정해야 한다.
  * 이때 구체적인 타입을 넘길 수도 있고 타입 파라미터로 받은 타입을 넘길 수도 있다.
  * 클래스가 자기 자신을 타입 인자로 참조할 수도 있다.

##### 타입 파라미터 제약

* 타입 파라미터 제약은 클래스나 함수에 사용할 수 이쓴 타입 인자를 제한하는 기능이다.
* 어떤 타입을 제네릭 타입의 타입 파라미터에 대한 상한으로 지정하면 그 제네릭 타입을 인스턴스화할 때 사용하는 타입 인자는 반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.

```kotlin
fun <T : Number> List<T>.sum(): T
```

* 타입 파라미터 T에 대한 상한을 정하고 나면 T 타입의 값을 그 상한 타입의 값으로 취급할 수 있다.
* 타입 파라미터에 대해 둘 이상의 제약을 가하는 경우 다른 구문을 사용한다.

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
   where T : CharSequence, T: Appendable {
     if (!seq.endsWith('.')) {
       seq.append('.')
     }
   }
```

##### 타입 파라미터를 널이 될 수 없는 타입으로 한정

* 항상 널이 될 수 없는 타입만 타입 인자로 받게 만들기 위해서는 `<Any>` 를 상한으로 사용한다.
  * `<T : Any>` 라는 제약은 `T` 타입이 항상 널이 될 수 없는 타입이 되게 보장한다.



#### 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

##### 실행 시점의 제네릭: 타입 검사와 캐스트

* 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
  * 이로 인해 실행 시점에 타입 인자를 검사할 수 없다.
* 코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없는데, 그렇다면 어떤 값이 맵이 아니라 리스트라는 사실은 어떻게 확인할까?
  * 스타 프로젝션을 사용하면 된다.
  * 타입 파라미터가 2개 이상이라면 모든 타입 파라미터에 `*` 를 포함시켜야 한다.
* `as` 나 `as?` 캐스팅에도 제네릭 타입을 사용할 수 있다.
  * 기저 클래스는 같지만 타입 인자가 다른 타입으로 캐스팅해도 캐스팅에 성공함을 주의해야 한다.
  * 이런 타입 캐스팅을 사용하면 컴파일러는 경고를 남긴다.
* 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 `is` 검사를 수행하게 허용한다.

##### 실체화한 타입 피라미터를 사용한 함수 선언

* 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.

> `inline` 키워드를 함수에 붙이면 컴파일러는 그 함수를 호출한 식을 모두 함수 본문으로 바꾼다. 함수가 람다를 인자로 사용하는 경우 그 함수를 인라인 함수로 만들면 람다 코드도 함께 인라이닝되고 그에 따라 무명 클래스와 객체가 생성되지 ㅇ낳아 성능이 더 좋아질 수 있다.

* 인라인 함수의 타입 파라미터를 `reified` 로 지정하면 타입을 실행 시점에 검사할 수 있다.

```kotlin
inline fun <reified T> isA(value: Any) = value is T
```

* 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입한다. 컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있으므로 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다. 타입 파라미터가 아니라 구체적인 타입을 사용하므로 만들어진 바이트코드는 실행 시점에 벌어지는 타입 소거의 영향을 받지 않는다.

##### 실체화한 타입 파라미터로 클래스 참조 대신

* `java.lang.Class` 타입 인자를 파라미터로 받는 API에 대한 코틀린 어댑터를 구축하는 경우 실체화한 타입 파라미터를 자주 사용한다.

````kotlin
val serviceImpl = ServiceLoader.load(Service::class.java)
val serviceImpl = loadService<Service>()

inline fun <reified T> loadService() { // 타입 파라미터를 reified로 표시
  return ServiceLoader.load(T::class.java) // T::class로 타입 파라미터의 클래스 가져오기
}
````

##### 실체화한 타입 파라미터의 제약

* 다음과 같은 경우에 실체화한 타입 파라미터를 사용할 수 있다.
  * 타입 검사와 캐스팅(`is`, `!is`, `as`, `as?`)
  * 코틀린 리플렉션 API(`::class`)
  * 코틀린 타입에 대응하는 `java.lang.Class` 얻기(`::class.java`)
  * 다른 함수를 호출할 때 타입 인자로 사용
* 다음과 같은 일은 할 수 없다.
  * 타입 파라미터 클래스의 인스턴스 생성
  * 타입 파라미터 클래스의 동반 객체 메소드 호출
  * 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
  * 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 `reified` 로 지정
    * 실체화한 타입 파라미터를 사용하는 함수는 자신에게 전달되는 모든 람다와 함께 인라이닝된다. 람다를 인라이닝하지 않고 싶은 경우 `noinline` 변경자를 함수 타입 파라미터에 붙여 인라이닝을 금지할 수 있다.



#### 변성: 제네릭과 하위 타입

##### 변성이 있는 이유: 인자를 함수에 넘기기

* `List<Any` 타입의 파라미터를 받는 함수에 `List<String>` 을 넘기는 경우 그 함수가 리스트의 원소를 추가하거나 변경한다며 타입 불일치가 생길 수 있어 `List<Any` 대신 `List<String>` 을 넘길 수 없다.
  * 원소 추가나 변경이 없는 경우에는 안전하다.
* 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 함수 호출을 막을 수 있다.

##### 클래스, 타입, 하위 타입

* 모든 코틀린 클래스는 적어도 둘 이상의 타입을 구성할 수 있다. (ex - `String`, `String?`)
* 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔 주어야 한다.
  * 예를 들어 `List` 는 타입이 아니지만 클래스다. 하지만 타입 인자를 치환한 `List<Int>` `List<String?>` 등은 모두 제대로 된 타입이다.
  * 각각의 제네릭 클래스는 무수히 많은 타입을 만들어낼 수 있다.
* 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제가 없다면 타입 B는 타입 A의 **하위 타입**이다. 
  * 이는 모든 타입이 자신의 하위 타입이라는 뜻이기도 하다.
* **상위 타입**은 하위 타입의 반대로 A 타입이 B 타입의 하위 타입이라면 B는 A의 상위 타입이다.
* 컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다.
  * 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용한다.
* 간단한 경우 하위 타입은 **하위 클래스**와 근본적으로 같다.
  * 어떤 인터페이스를 구현하는 클래스의 타입은 그 인터페이스 타입의 하위 타입이다.
  * 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이지만 두 타입 모두 같은 클래스에 해당한다.
* 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 **무공변**이라고 말한다.

##### 공변성: 하위 타입 관계를 유지

* A가 B의 하위 타입일 때 `Producer<A>`가 `Producer<B>` 의 하위 타입이면 `Producer` 는 공변적이며, 하위 타입 관계가 유지된다고 말한다.
* 코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 앞에 `out` 을 넣어야 한다.
* 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스터스를 함수 인자나 반환 값으로 사용할 수 있다.
* 모든 클래스를 공변적으로 만들 수는 없다. 공변적으로 만들면 안전하지 못한 클래스도 있다.
  * 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.
  * 타입 안전성을 보장하기 위해 공변적 파라미터는 항상 아웃*out* 위치에 있어야 한다. 즉, 클래스가 `T` 타입의 값을 **생산할 수는 있지만 `T` 타입의 값을 소비할 수는 없다**는 뜻이다.
  * `T`라는 타입 파라미터를 선언하고 `T` 를 사용하는 함수가 멤버로 있는 클래스가 있을 때, `T` 가 함수의 반환 타입에 쓰인다면 `T`는 아웃 위치에 있고 그 함수는 `T` 타입의 값을 생산한다. `T` 가 함수의 파라미터 타입에 쓰인다면 `T` 는 인 위치에 있고 그 함수는 `T` 타입의 값을 소비한다.
  * 클래스 타입 파라미터 앞에 `out` 키워드를 붙이면 클래스 안에서 해당 타입을 사용하는 메소드가 아웃 위치에서만 사용하게 허용한다. 즉, 사용법을 제한하고 하위 타입 관계의 타입 안전성을 보장한다.
* 타입 파라미터 `T` 에 붙은 `out` 키워드는 아래의 두 가지를 함께 의미한다.
  * **공변성**: 하위 타입 관계가 유지된다. (`Producer<Cat`은 `Producer<Animal>` 의 하위 타입이다.)
  * **사용 제한**: `T`를 아웃 위치에서만 사용할 수 있다.
* 생성자 파라미터는 인이나 아웃 어느 쪽도 아니다.
* 변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듦으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할을 한다.
* `val` 이나 `var` 키워드를 생성자 파라미터에 적는다면 게터나 세터를 정의하는 것과 같다. 따라서 읽기 전용 프로퍼티는 아웃 위치, 변경 가능 프로퍼티는 아웃과 인 위치 모두에 해당한다.
* 이런 위치 규칙은 오직 외부에서 볼 수 있는 클래스 API에만 적용할 수 있다. 변성 규칙은 클래스 외부의 사용자가 클래스를 잘못 사용하는 일을 막기 위한 것이므로 클래스 내부 구현에는 적용되지 않는다.

##### 반공변성: 뒤집힌 하위 타입 관계

* 반공변 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.

```kotlin
interface Comparator<in T> {
  fun compare(e1: T, e2: T) : Int { ... }
}
```

* `T`가 인 위치에서만 쓰이므로 앞에 `in` 키워드를 붙여야 한다.
  * `in` 이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼 메소드에 의해 소비된다는 뜻이다.
* 타입 B가 타입 A의 하위 타입인 경우 `Comsumer<A>`가 `Consumer<B>`의 하위 타입인 관계가 성립하면 제네릭 클래스 `Comsumer<T>`는 타입 인자 `T`에 대해 반공변이다.
  * A와 B의 위치가 서로 뒤바뀐다는 점을 유의하자. 하위 타입 관계가 뒤집힌다.

![](https://user-images.githubusercontent.com/55083845/141160397-a8c90faa-041c-470e-8d12-873eb6c74729.jpg)

| 공변성                                                   | 반공변성                                               | 무공변성                              |
| -------------------------------------------------------- | ------------------------------------------------------ | ------------------------------------- |
| `Producer<out T>`                                        | `Consumer<in T>`                                       | `MutableList<T>`                      |
| 타입 인자의 하위 타입 관계가 제네릭 타입에서도 유지된다. | 타입 인자의 하위 타입 관계가 제네릭 타입에서 뒤집힌다. | 하위 타입 관계가 성립하지 않는다.     |
| `Producer<Cat>`은 `Producer<Animal>`의 하위 타입이다.    | `Consumer<Animal`은 `Consumer<Cat`의 하위 타입이다.    |                                       |
| `T`를 아웃 위치에서만 사용할 수 있다.                    | `T`를 인 위치에서만 사용할 수 있다.                    | `T`를 아무 위치에서나 사용할 수 있다. |

* 클래스나 인터페이스나 어떤 타입 파라미터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는 반공변적일 수 있다.

##### 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정

* 클래스를 선언하면서 변성을 지정해 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 끼치게 하는 방식을 **선언 지점 변성**이라고 한다.
* 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시하는 방식을 **사용 지점 변성**이라고 한다. 코틀린도 사용 지점 변성을 지원한다.
* 함수 구현이 아웃 위치 또는 인 위치에 있는 타입 파라미터를 사용하는 메소드만 호출한다면 그런 정보를 바탕으로 함수 정의 시 타입 파라미터에 변성 변경자를 추가할 수 있다.

```kotlin
fun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {
  for (item in source) {
    destination.add(item)
  }
}
```

* 타입 선언에서 타입 파라미터를 사용하는 위치라면 어디에나 변성 변경자를 붙일 수 있다.
  * 이때 타입 프로젝션이 일어난다. 즉, `source`를 일반적인 `MutableList`가 아니라 `MutableList`를 제약을 가한 타입으로 만든다. 이 경우 `copyData` 함수는 `MutableList`의 메소드 중에서 반환 타입으로 타입 파라미터 `T`를 사용하는 메소드-아웃 위치에서 사용하는 메소드-만 호출할 수 있다.
  * `in`의 경우도 마찬가지로 타입 파라미터가 쓰이는 위치 앞에 변경자를 붙여 그 위치에 있는 값이 소비자 역할을 수행한다고 표시할 수 있다.

> 코틀린의 사용 지점 변성 선언은 자바의 한정 와일드카드와 똑같다. 코틀린 `MutableList<out T>` 는 자바 `MutableList<? Extends T>`, 코틀린 `MutableList<in T>` 는 자바 `MutableList<? super T>` 와 같다.

##### 스타 프로젝션: 타입 인자 대신 * 사용

* `MutableList<*>` 는 어떤 정해진 구체적인 타입의 원소만을 담는 리스트지만 그 원소의 타입을 **정확히 모른다**는 사실을 표현한다.
  * 원소 타입이 어떤 것인지 모른다고 해서 아무 원소나 담아도 된다는 뜻은 아니다.
  * 스타 프로젝션을 사용한 경우 그 클래스 혹은 인터페이스를 특정 타입을 위해 사용하려고 하면 코틀린 컴파일러는 안전하지 않다고 판단한다. 스타 프로젝션을 사용한 클래스 혹은 인터페이스가 해당 타입을 위한 것인지 알 수 없기 때문이다. 
    * 이 경우 타입 캐스팅을 할 수 있지만, 컴파일러는 타입 캐스팅이 안전하지 못하다고 경고한다. 이런 경우 타입을 제대로 검사하도록 캡슐화할 수 있다.
* 컴파일러는 `MutableList<*>` 를 아웃 프로젝션 타입으로 인식한다. 
  * 즉 `MutableList<out Any?>` 처럼 동작한다. 어떤 리스트의 원소 타입을 모르더라도 그 리스트에서 안전하게 `Any?` 타입의 원소를 꺼내올 수 있지만-`Any?`는 모든 코틀린 타입의 상위 타입-타입을 모르는 리스트에 원소를 마음대로 넣을 수는 없다.
* 타입 파라미터를 시그니처에서 전혀 언급하지 않거나 데이터를 읽기는 하지만 그 타입에는 관심이 없는 경우와 같이 타입 인자 정보가 중요하지 않을 때도 스타 프로젝션 구문을 사용할 수 있다.
  * 스타 프로제션을 사용할 때는 값을 만들어내는 메소드만 호출할 수 있고 그 값의 타입에는 신경 쓰지 말아야 한다.