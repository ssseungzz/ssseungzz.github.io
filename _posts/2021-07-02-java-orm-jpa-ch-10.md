---
title: "JPA 뽀개기 - 객체지향 쿼리 언어"
categories:
  - Develop
tags:
  - jpa
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 10. 객체지향 쿼리 언어

### JPQL

* JPQL의 특징
  * 객체지향 쿼리 언어다. 엔티티 객체를 대상으로 쿼리한다.
  * SQL을 추상화해 특정 데이터베이스에 의존하지 않는다.
  * 결국 SQL로 변환된다.

##### 기본 문법과 쿼리 API

* SELECT 문
  * `SELECT m FROM Member AS m where m.username = 'Hello'`
  * 대소문자 구분: 엔티티와 속성은 대소문자를 구분한다. JPQL 키워드는 대소문자를 구분하지 않는다.
  * 엔티티 이름: 클래스 명이 아니라 엔티티 명을 사용한다.
  * 별칭 필수: JPQL은 별칭을 필수로 사용해야 한다. 단, 키워드 `AS`는 생략 가능하다.
* TypeQuery, Query
  * 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.
  * 반환할 타입을 명확하게 지정할 수 있으면 `TypeQuery`를 사용하고, 명확하게 지정할 수 없으면 `Query` 객체를 사용하면 된다.
  * `TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class)` <- 조회 대상이 엔티티로 명확
  * `Query query = em.createQuery("SELECT m.username, m.age FROM Member m")` <- 여러 컬럼(혹은 엔티티)이므로 반환할 타입이 명확하지 않음
  * `Query` 객체는 SELECT 절의 조회 대상이 둘 이상이면 `Object[]` 를 반환하고 하나면 `Object`를 반환한다.
  * `query.getResultList()`, `query.getSingleResult` 등을 호출해 실제 쿼리를 실행해 데이터베이스를 조회한다. 후자는 결과가 정확히 한 개가 아니면 예외가 발생한다.

##### 파라미터 바인딩

* 이름 기준 파라미터

  * 파라미터를 이름으로 구분하는 방법이다. 앞에 `:`를 사용한다.

  ```java
  String usernameParam = "User1";
  TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m where m.username = :username", Member.class);
  query.setParameter("username", usernameParam);
  List<Member> resultList = query.getResultList();
  ```

  * JPQL API는 대부분 메소드 체인 방식으로 설계되어 있어 위의 메소드들을 연속해서 작성 가능하다.

* 위치 기준 파라미터

  * `?` 다음에 위치 값을 주면 된다. 위치 값은 1부터 시작한다. 

  ```java
  List<Member> members =
    em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class)
    .setParameter(1, usernameParam);
  	.getResultList();
  ```

  * SQL 파라미터 바인딩 방식 대신 직접 문자를 더해 만들면 SQL 인젝션 공격을 당할 수 있을 뿐더러 해당 쿼리의 파싱 결과를 재사용할 수 없어 성능이 저하될 수 있다. 

##### 프로젝션

SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라고 하고 `SELECT {프로젝션 대상} FROM`으로 대상을 선택한다. 프로젝션 대상은 엔티티, 임베디드 타입, 스칼라 타입(문자, 숫자 등 기본 데이터 타입)이 있다.

* 엔티티 프로젝션

  * 원하는 객체를 바로 조회한다. 이렇게 조회한 엔티티는 **영속성 컨텍스트에서 관리**된다.

* 임베디드 타입 프로젝션

  * 엔티티 타입과 거의 비슷하게 사용되며 조회의 시작점은 될 수 없다.
  * 엔티티를 통해서 임베디드 타입을 조회할 수 있다. 

  ```java
  String query = "SELECT o.address FROM Order o";
  List<Address> addresses = em.createQuery(query, Address.class)
    														.getResultList();
  ```

  * 엔티티 타입이 아닌 값 타입이므로 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.

* 스칼라 타입 프로젝션

  * 숫자, 문자, 날짜와 같은 기본 데이터 타입을 스칼라 타입이라 한다.
  * 임베디드 타입과 마찬가지로 조회 가능하다.

* 여러 값 조회

  * 프로젝션에 여러 값을 선택하면 `Query`를 사용해야 한다. 요소 하나가 컬럼 하나로 이루어진 배열의 배열을 결과로 받는다.
  * 엔티티 타입도 여러 값을 함께 조회할 수 있다. 이때도 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

* NEW 명령어

  * 실제 개발에는 `Query`에서 받는 `Object[]`를 직접 사용하지 않고 `UserDTO`처럼 의미 있는 객체로 변환해서 사용된다.
  * SELECT 다음에 `NEW` 명령어를 사용하면 반환받을 클래스를 지정할 수 있는데 이 클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있다. 

  ```java
  TypedQuery<UserDTO> query = 
    em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);
  List<UserDTO> resultList = query.getResultList();
  ```

  * NEW 명령어 사용 시 패키지 명을 포함한 전체 클래스 명을 입력해야 하며 순서와 타입이 일치하는 생성자가 필요하다.

##### 페이징 API

* `setFirstResult(int startPosition)`: 조회 시작 위치(0부터 시작)
* `setMaxResults(int maxResult`): 조회할 데이터 수
* 위의 두 가지 API로 페이징을 추상화한다. 페이징을 더 최적화하고 싶은 경우 네이티브 SQL을 사용한다.

##### 집합과 정렬

* 집합 함수: `COUNT`(returns `Long`), `MAX`, `MIN`, `AVG`(returns `Double`), `SUM`(returns `Long` | `Double` | `BigInteger` | `BigDecimal`)
* 참고
  * `NULL` 값은 무시한다.
  * 값이 없는데 집합 함수를 사용하면 `NULL` 값이 된다. 단, `COUNT`는 0이 된다.
  * `DISTINCT`를 집합 함수 안에 사용해서 중복 제거하고 집합을 구할 수 있다.
  * `DISTINCT`를 `COUNT`에서 사용할 때 임베디드 타입은 지원하지 않는다.
* `GROUP BY` , `HAVING`
  * `GROUP BY {단일값 경로 | 별칭}+`
  * `HAVING 조건식`
* 정렬(`ORDER BY`)
  * `ORDER BY {상태필드 경로 | 결과 변수 {ASC | DESC}}+`
  * 결과 변수는 SELECT 절에 나타나는 값을 말한다.

##### JPQL 조인

* 내부 조인
  * `INNER JOIN` 사용
  * JPQL의 조인은 연관 필드를 사용한다. 연관 필드는 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드를 말한다.
* 외부 조인
  * `OUTER`는 생략 가능해 보통 `LEFT JOIN` 사용

* 컬레션 조인
  * 일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것을 컬렉션 조인이라 한다.
  * 단일 값 연관 필드를 사용한 조인과 달리 컬렉션 값 연관 필드를 사용한다.
* 세타 조인
  * `WHERE` 절을 이용해서 세타 조인을 할 수 있다. 세타 조인은 내부 조인만 지원한다. 전혀 관계없는 엔티티도 조인할 수 있다.
* JOIN ON 절(JPA 2.1)
  * ON 절을 사용하면 조인 대상을 필터링하고 조인할 수 있다. 내부 조인의 ON 절은 WHERE 절을 사용할 때와 결과가 같으므로 ON 절은 외부 조인에서만 사용한다. 
  * 조인 지섬에 조인 대상을 필터링한다.

##### 페치 조인

JPQL에서 성능 최적화를 위해 조회하는 기능이다. 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능인데 `join fetch` 명령어로 사용할 수 있다.

* 엔티티 페치 조인

  * `select m from Member m join fetch m.team`

  * 연관된 엔티티나 컬렉션을 함께 조회한다. 페치 조인은 별칭을 조인 대상에 별칭을 사용할 수 없다.

    > 하이버네이트는 페치 조인에도 별칭을 허용한다.

  * 객체 그래프를 유지하며 조회된다.

  * 회원과 팀을 지연 로딩으로 설정했다고 가정하고 회원을 조인할 때 페치 조인을 사용하면 페치 조인 시 팀도 함꼐 조회되므로 연관된 팀 엔티티는 프록시가 아니라 실제 엔티티이다. 따라서 연관된 팀을 사용해도 지연 로딩이 일어나지 않고 회원 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되어도 연관된 팀을 조회할 수 있다.

* 컬렉션 페치 조인

  * 다대일, 일대일 조인의 경우 결과가 증가하지 않는다. 일대다 조인은 결과가 증가할 수 있다.

* 페치 조인과 DINSTINCT

  * 각 로우의 데이터가 다르면 효과가 없다.

* 페치 조인과 일반 조인의 차이

  * JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 특정한 엔티티만 조회한다.
  * 따라서 `select t from Team t join t.members m where t.name = 'teamA'`라는 쿼리 작성 시 팀 엔티티만 조회하고 연관된 회원 컬렉션은 조회하지 않는다. 만약 회원 컬렉션을 지연 로딩으로 설정하면 프록시나 아직 초기화하지 않은 컬렉션 래퍼를 반환한다.
  * 반면 페치 조인을 사용하면 연관된 엔티티도 함께 조회한다.

* 페치 조인의 특징과 한계

  * SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어 SQL 호출 횟수를 줄여 성능을 최적화할 수 있다.
  * 엔티티에 직접 적용하면 로딩 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라고 하는데, 페치 조인은 글로벌 로딩 전략보다 우선한다. 
  * 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어나므로 될 수 있으면 지연 로딩을 사용하고 최적화 필요 시 페치 조인을 적용하는 것이 효과적이다.
  * 페치 조인 사용 시 연관된 엔티티를 쿼리 시점에 조회하므로 지연 로딩이 발생하지 않는다. 따라서 준영속 상태에서도 객체 그래프를 탐색할 수 있다.
  * 페치 조인 대상에는 별칭을 줄 수 없다.
  * 둘 이상의 컬렉션을 페치할 수 없다.
  * 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다. 단일 값 연관 필드들은 페치 조인을 사용해도 페이징 API를 사용할 수 있다.

##### 경로 표현식

경로 표현식은 점을 찍어 객체그래프를 탐색하는 것이다.

* 용어
  * 상태 필드: 단순히 값을 저장하기 위한 필드(필드 or 프로퍼티)
  * 연관 필드: 연관관계를 위한 필드, 임베디드 타입 포함(필드 or 프로퍼티)
    * 단일 값 연관 필드: `@ManyToOne`, `OneToOne`, 대상이 엔티티
    * 컬렉션 값 연관 필드: `@OneToMany`, `@ManyToMany`, 대상이 컬렉션
* 경로 표현식과 특징
  * 상태 필드 경로: 경로 탐색의 끝이다. 더는 탐색할 수 없다.
  * 단일 값 연관 경로: 묵시적으로 내부 조인이 일어난다. 단일 값 연관 경로는 계속 탐색할 수 있다.
  * 컬렉션 값 연관 경로: 묵시적으로 내부 조인이 일어난다. 더는 탐색할 수 없다. 단 FROM 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색할 수 있다.
* 단일 값 연관 경로 탐색
  * 단일 값 연관 필드로 경로 탐색을 하면 SQL에서 내부 조인이 일어나는데 이를 묵시적 조인이라 한다. 묵시적 조인은 모두 내부 조인이다.
* 컬렉션 값 연관 경로 탐색
  * 컬렉션까지는 경로 탐색이 가능하지만 컬렉션에서 경로 탐색을 시작하는 것은 허락하지 않는다.
  * 컬렉션에서 경로 탐색을 시작하고 싶으면 조인을 사용해 새로운 별칭을 획득해야 한다.
* 경로 탐색을 이용한 묵시적 조인 시 주의사항
  * 항상 내부 조인이다.
  * 컬렉션의 경우 경로 탐색을 하려면 명시적으로 조인해서 별칭을 얻어야 한다.
  * 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 준다.

##### 서브쿼리

* JPQL은 서브쿼리를 WHERE, HAVING 절에서만 사용할 수 있고 SELECT, FROM 절에서는 사용할 수 없다.
* [NOT] EXISTS, {ALL | ANY | SOME}, [NOT] IN 함수와 서브쿼리는 같이 사용할 수 있다.

##### 조건식

* 타입 표현
  * 거의 SQL과 유사하며 대소문자는 구분하지 않는다.
* 연산자 우선 순위
  * 경로 탐색 연산이 가장 우선한다.
* 논리 연산
  * 흔히 아는 것과 같음
* Between, IN, Like NULL, 비교
  * Between은 경계값을 포함
  * NULL은 무조건 `IS NULL` 사용
* 컬렉션 식
  * 컬렉션 식은 컬렉션에만 사용하는 특별한 기능이다.
  * 빈 컬렉션 비교 식: `{컬렉션 값 연관 경로} IS [NOT] EMPTY`
  * 컬렉션의 멤버 식: `(엔티티나 값) [NOT] MEMBER [OF] {컬렉션 값 연관 경로}`
* 스칼라 식
  * SQL과 유사
* 수학함수
* 날짜함수
* CASE식
  * 특정 조건에 따라 분기할 때 사용한다.

##### 다형성 쿼리

* JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회한다.
* TYPE
  * 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 사용한다.
  * `select i from Item i where type(i) IN (book, Movie)`
* TREAT
  * 부모 타입을 특정 자식 타입으로 다룰 때 사용한다. JPA 표준은 FROM, WHERE 절에서 사용할 수 있다.
  * `select i from Item i where treat(i as book).author = 'kim'`

##### 사용자 정의 함수 호출

* 하이버네이트 구현체를 사용하면 방언 클래스를 상속해서 구현하고 사용할 데이터베이스 함수를 미리 등록해야 한다.

##### 기타 정리

* `enum`은 `=` 비교 연산만 지원한다.
* 임베디드 타입은 비교를 지원하지 않는다.
* 빈 문자열의 경우 데이터베이스에 따라 `NULL`로 사용할 수 있으므로 확인해야 한다.
* NULL 정의
  * 조건을 만족하는 데이터베이스가 하나도 없음
  * 알 수 없는 값으로 NULL과의 모든 수학적 계산 결과는 NULL
  * Null == Null은 알 수 없는 값
  * Null is Null은 참

##### 엔티티 직접 사용

* 기본 키 값
  * 객체 인스턴스는 참조 값으로 식별하고 테이블 로우는 기본 키 값으로 식별한다. 따라서 JPQL에서 엔티티 객체를 직접 사용하면 SQL에서는 해당 엔티티의 기본 키 값을 사용한다.
* 외래 키 값
  * 연관 필드를 사용하면 해당 필드 엔티티의 식별자 값을 사용한다.

##### Named 쿼리: 정적 쿼리

* 동적 쿼리: JPQL을 문자로 완성해서 직접 넘기는 것을 동적 쿼리라고 한다. 런타임에 특정 조건에 따라 JPQL을 동적으로 구성할 수 있다.
* 정적 쿼리: 미리 정의한 쿼리에 이름을 부여해 필요할 때 사용할 수 있는데 이를 Named 쿼리라 한다. 한번 정의하면 변경할 수 없다.
* 정적 쿼리는 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해 둔다. 따라서 오류를 빨리 확인할 수 있고, 사용하는 시점에는 파싱된 결과를 재사용하므로 성능상 이점도 있다. 정적 SQL이 생성되므로 데이터베이스 조회 성능 최적화에도 도움이 된다.
  * `@NamedQuery` 어노테이션을 사용해서 자바 코드에 작성 가능하다. 사용할 때는 `em.createNamedQuery` 메소드에 쿼리 이름을 입력한다.
  * XML로도 설정이 가능하다. 어노테이션과 같은 설정이 있으면 XML이 우선한다.



#### QueryDSL

* 쉽고 간결하며 쿼리와 비슷하게 쿼리를 코드로 작성할 수 있는 프로젝트이다.

##### QueryDSL 설정

* 라이브러리 추가
* 쿼리 타입 생성용 플러그인 추가

##### QueryDSL 시작

* `JPAQuery` 객체를 생성한다. 이때 엔티티 매니저를 생성자에 넘겨준다.
* 사용할 쿼리 타입(`Q` )을 생성하는데 생성자에는 별칭을 주면 된다. 이 별칭을 JPQL에서 별칭으로 사용한다.
* 기본 Q 생성
  * 쿼리 타입은 사용하기 편리하도록 기본 인스턴스를 보관하고 있다. 
  * 같은 엔티티를 조인하거나 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용되므로 이때는 별칭을 직접 지정해서 사용해야 한다.

##### 검색 조건 쿼리

* where절에는 and나 or을 사용할 수 있다.

##### 결과 조회

* `uniqueResult()`: 조회 결과가 한 건일 때 사용한다. 둘 이상이면 예외가 발생한다.
* `singleResult()`: 위의 메소드와 같지만 결과가 하나 이상이면 처음 데이터를 반환한다.
* `list()`: 결과가 하나 이상일 때 사용한다. 없으면 빈 컬렉션을 반환한다.

##### 페이징과 정렬

* 정렬은 `orderBy` 사용
* 페이징은 `offset`과  `limit` 사용
* 실제 페이징 처리를 하려면 검색된 전체 데이터 수를 알아야 하므로 `list()` 대신 `listResults()`를 사용한다.
  * 이 메소드를 사용하면 전체 데이터 조회를 위한 count 쿼리를 한 번 더 실행한다.

##### 그룹

* `groupBy`를 사용하고 결과를 제한하려면  `having`을 사용하면 된다.

##### 조인

* `innerJoin(join)`, `leftJoin, rightJoin, fullJoin` 사용 가능
* `on`과 성능 최적화를 위한 `fetch` 조인도 사용할 수 있다.
* 조인의 기본 문법은 첫 번째 파라미터에 조인 대상을 지정하고 두 번째 파라미터에 별칭으로 사용할 쿼리 타입을 지정하면 된다.

##### 서브 쿼리

* `JPASubQuery`를 생성해서 사용한다. 서브 쿼리의 결과가 하나면 `unique()`, 여러 건이면 `list()`를 사용한다.

##### 프로젝션과 결과 반환

* 프로젝션 대상이 하나
  * 프로젝션 대상이 하나면 해당 타입으로 반환한다.
* 여러 컬럼 반환과 튜플
  * 여러 필드를 선택하면 QueryDSL은 기본으로 `Map`과 비슷한 내부 타입을 사용한다. 조회 결과는 `get` 메소드에 조회한 쿼리 타입을 지정하면 된다.
* 빈 생성
  * 쿼리 결과를 엔티티가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용한다. 프로퍼티 접근, 필드 직접 접근, 생성자 사용 등 객체를 생성하는 다양한 방법을 제공한다.

##### 수정, 삭제 배치 쿼리

* 영속성 컨텍스트를 무시하고 데이터베이스를 직접 쿼리한다.

##### 동적 쿼리

* `BooleanBuilder`를 사용하면 특정 조건에 따른 동적 쿼리를 편리하게 생성할 수 있다.

##### 메소드 위임

* 쿼리 타입에 검색 조건을 직접 정의할 수 있다.
* 메소드 위임 기능을 사용하려면 정적 메소드를 만들고 `QueryDelegate` 어노테이션에 속성으로 이 기능을 적용할 엔티티를 지정한다. 정적 메소드의 첫 번째 파라미터에는 대상 엔티티의 쿼리 타입을 지정하고 나머지는 필요한 파라미터를 정의한다.

```java
public class ItemExpression {
  @QueryDelegate(Item.class)
  public static BooleanExpression isExpensive(QItem item, Integer price) {
    return item.price.gt(price);
  }
}

public class QItem extends EntityPathBase<Item> {
  public com.mysema.query.types.expr.BooleanExpression isExpensive(Integer price) {
    return ItemExpresion.isExpensive(this, price);
  }
}

query.from(item).where(item.isExpensive(30000)).list(item);
```



#### 객체지향 쿼리 심화

##### 벌크 연산

* 벌크 연산은 `executeUpdate()` 메소드를 사용한다. 이 메소드는 벌크 연산으로 영향을 받은 엔티티 건수를 반환한다.
* 벌크 연산의 주의점
  * 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다.
  * 따라서 영속성 컨텍스트와 데이터베이스가 불일치할 수 있다.
  * 이를 해결하기 위해 `em.refresh`로 데이터베이스에서 다시 엔티티를 조회하거나 조회 메소드보다 먼저 벌크 연산을 실해앟ㄴ다. 또는 벌크 연산 수행 수 영속성 컨텍스트를 초기화한다.

##### 영속성 컨텍스트와 JPQL

* 쿼리 후 영속 상태인 것과 아닌 것

  * 엔티티를 JPQL로 조회하면 영속성 컨텍스트에서 관리되지만 엔티티가 아니면 영속성 컨텍스트에서 관리되지 않는다. 가령, 임베디드 타입은 조회해서 값을 변경해도 영속성 컨텍스트가 관리하지 않으므로 변경 감지에 의한 수정이 발생하지 않는다. 

  * JPQL로 조회한 엔티티와 영속성 컨텍스트

    1. JPQL을 사용해 조회를 요청
    2. JPQL은 SQL로 변환되어 데이터베이스 조회
    3. 조회한 결과와 영속성 컨텍스트를 비교
    4. 식별자 값을 기준으로 영속성 컨텍스트에 있는 엔티티는 버려지고 기존에 (영속성 컨텍스트에) 있던 엔티티가 반환 대상
    5. 식별자 값을 기준으로 영속성 컨텍스트에 없는 엔티티는 영속성 컨텍스트에 추가
    6. 이렇게 만들어진 (쿼리) 결과를 반환

    * 결론: JPQL로 조회한 엔티티는 영속 상태이며 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다. 이는 영속 상태인 엔티티의 동일성을 보장하기 위함이다.

* `find()` vs JPQL

  * `find()` 메소드는 해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로 성능상 이점이 있다.
  * JPQL은 항상 데이터베이스에서 SQL을 실행해서 결과를 조회한다. 이미 영속성 컨텍스트에 엔티티가 존재하면 새로 검색한 엔티티는 버리고 영속성 컨텍스트에 있는 기존 엔티티를 반환한다.
  * JPQL은 항상 데이터베이스를 조회하며 조회한 엔티티는 영속 상태이고, 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.

##### JPQL과 플러시 모드

* 플러시는 영속성 컨텍스트의 변경 내역을 데이터베이스에 동기화하는 것이다. JPA는 플러시가 일어날 때 영속성 컨텍스트에 등록, 수정, 삭제한 엔티티를 찾아서 SQL을 만들어 데이터베이스에 반영한다.
* 보통 플러시 모드에 따라 커밋하기 직전이나 쿼리 실행 직전에 자동으로 플러시가 호출된다. 커밋 시에만 플러시를 호출하는 옵션은 성능 최적회를 위해 꼭 필요할 때만 사용해야 한다.

##### 쿼리와 플러시 모드

* JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 데이터베이스에서 데이터를 조회하므로 실행 전 영속성 컨텍스트의 내용을 데이터베이스에 반영해야 한다.
* 쿼리에 설정하는 플러시 모드는 엔티티 매니저에 설정하는 플러시 모드보다 우선권을 가진다. 따라서 쿼리에서만 사용할 플러시 모드를 `setFlushMode` 메소드로 설정해 주면 엔티티 매니저에 설정된 플러시 모드와 달라도 적용된다.

##### 플러시 모드와 최적화

* `FlushMode.COMMIT` 모드는 트랜잭션을 커밋할 때만 플러시하고 쿼리를 실행할 때는 플러시하지 않는다. 이런 상황은 데이터베이스 무결성에 피해를 줄 수 있지만 플러시가 너무 자주 일어나는 상황에서는 이 모드를 사용하면 쿼리시 발생하는 플러시 횟수를 줄여 성능을 최적화할 수 있다.
* JPA를 사용하지 않고 JDBC를 직접 사용해서 SQL을 실행하면 JPA는 JDBC가 실행한 쿼리를 인식할 방법이 없다. 따라서 별도의 JDBC 호출은 플러시 모드를 AUTO 설정해도 플러시가 일어나지 않는다. 이때는 JDBC로 쿼리를 실행하기 직전에 `em.flush()`를 호출해서 영속성 컨텍스트의 내용을 데이터베이스에 동기화하는 것이 안전하다.