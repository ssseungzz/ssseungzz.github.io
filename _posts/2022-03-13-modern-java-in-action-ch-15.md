---
title: "Modern Java in Action 15장; CompletableFuture와 리액티브 프로그래밍 컨셉의 기초"
categories:
  - Language
tags:
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 15. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
* 멀티코어 프로세서가 발전하면서 애플리케이션의 속도는 멀티코어 프로세서를 얼마나 잘 활용할 수 있도록 소프트웨어를 개발하는가에 따라 달라질 수 있다.
* 인터넷 서비스에서 사용하는 애플리케이션이 증가하고 있다.
    * 마이크로서비스 아키텍처 선택이 증가했다.
    * 여러 웹 서비스에 접근해 응답을 기다리는 동안 연산이 블록되거나 CPU 클록 사이클을 낭비하지 않도록 하는 기법이 발전했다.
    * 한 태스크를 여러 하위 태스크로 나누어 CPU의 다른 코어 또는 다른 머신에서 이들 하위 태스크를 병렬로 실행하거나(병렬성) 조금씩 연관된 작업을 같은 CPU에서 동작하는 것 또는 생산성을 극대화할 수 있도록 코어를 바쁘게 유지(동시성)하면서도 원격 서비스나 데이터베이스 결과를 기다리는 스레드를 블록함으로 연산 자원을 낭비하는 일은 피해야 한다.
* 동시성은 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성으로 실행이 서로 겹칠 수 있는 반면 병렬성은 병렬 실행을 하드웨어 수준에서 지원한다.

#### 15.1 동시성을 구현하는 자바 지원의 진화
* 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원하면서 다양한 웹 서비스를 이용하고 이들 정보를 실시간으로 조합해 사용자에게 제공하거나 추가 웹 서비스를 통해 제공하는 종류의 애플리케이션을 개바하는 데에 필수적인 기초 모델과 툴킷을 제고앟ㄴ다.
    * 이 과정을 리액티브 프로그래밍이라 부르며 자바 9에서는 발행-구독 프로토콜(`java.util.concurrent.Flow` 인터페이스 추가)로 이를 지원한다.
    * `CompletableFuture`와 `java.util.concurrent.Flow`는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것을 목표로 한다.

##### 15.1.1 스레드와 높은 수준 추상화
* 운영체제는 CPU를 프로세스에 할당하고 프로세스는 다시 운영체제에 한 개 이상의 스레드 즉, 본인이 가진 프로세스와 같은 주소 공간을 공유하는 프로세스를 요청함으로써 태스크를 동시에 또는 협력적으로 실행할 수 있다.
* 멀티코어 설정에서는 스레드의 도움 없이 프로그램이 컴퓨팅 파워를 모두 활용할 수 없다. 각 코어는 한 개 이상의 프로세스나 스레드에 할당될 수 있지만 프로그램이 스레드를 사용하지 않는다면 효율성을 고려해 여러 프로세서 코어 중 하나만을 사용할 것이다.
* 스트림을 이용해 스레드 사용 패턴을 추상화할 수 있다.

##### 15.1.2 Executor와 스레드 풀
###### 스레드의 문제
* 자바 스레드는 직접 운영체제 스레드에 접근하는데, 운영체제 스레드를 사용하는 데에는 비용이 많이 든다. 게다가 운영체제 스레드의 숫자는 제한되어 있어 초과하면 애플리케이션이 예상치 못하게 동작할 수 있다.
* 운영체제와 자바의 스레드 개수가 하드웨어 스레드 개수보다 많으므로 일부 운영체제 스레드가 불록되거나 자고 있는 상황에서 모든 하드웨어 스레드가 코드를 실행하도록 할당된 상황에 놓을 수 있다.

###### 스레드 풀 그리고 스레드 풀이 더 좋은 이유
* `Executor`는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공하며 팩토리 메서드로 스레드 풀을 만들어 사용할 수 있다.
* 워커 스레드라 불리는 `nThreads`를 포함하는 `ExecutoreService`를 만들고 이들을 스레드 풀에 저장한다. 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행하고 종료되면 반환한다.
    * 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수천 개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출 가능하다.
    * 프로그래머는 태스크(`Runnable`이나 `Callable`)를 제공하면 스레드가 이를 실행한다.

###### 스레드 풀 그리고 스레드 풀이 나쁜 이유
* k 스레드를 가진 스레드 풀은 오직 k만큼의 스레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며 이전에 태스크 중 하나가 종료되기 전까지는 스레드에 할당하지 않는다. 잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 스레드가 있다면 주의해야 한다. 블록 상황에서 이들 태스크가 워커 스레드에 할당된 상태를 유지하지만 아무 작업도 하지 않게 된다.
* 중요한 코드를 실행하는 스레드가 죽는 일이 발생하지 않도록 보통 자바 프로그램은 `main`이 반환하기 전에 모든 스레드의 작업이 끝나길 기다린다. 따라서 프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다. 풀의 워커 스레드가 만들어진 다음 다른 태스크 제출을 기다리면서 종료되지 않은 상태일 수 있기 때문이다.

##### 15.1.3 스레드의 다른 추상화: 중첩되지 않은 메서드 호출
* 태스크나 스레드가 메서드 호출 안에서 시작되면 그 메서드 호출은 반환하지 않고 작업이 끝나기를 기다리는, 즉 스레드 생성과 `join()`이 한 쌍처럼 중첩된 메서드 호출 내에 추가된 것을 엄격한 포크/조인이라 부른다.
* 시작된 태스크를 외부 호출에서 종료하도록 기다리는 여유로운 방식의 포크/조인을 사용해도 비교적 안전하다.
    * 메서드 호출자에 기능을 제공하도록 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드를 비동기 메서드라 한다.
    * 스레드 실행은 메서드를 호출한 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않도록 주의해야 하며 기존 실행 중이던 스레드가 종료되지 않은 상황에서 `main()` 메서드가 반환화면 애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼 때까지 기다리든(잊고서 종료를 못한 스레드에 의해 애플리케이션 크래시, 혹은 I/O 작업 중단 시 데이터 일관성 파괴 가능성) 애플리케이션 종료를 방해하는 스레드를 강제종료시키고 애플리케이션을 종료하든 안전하지 못하다.
    * 자바 스레드는 데몬 또는 비데몬으로 구분 가능한데 데몬 스레드는 애플리케이션이 종료될 때 강제 종료되므로 데이터 일관성을 파괴하지 않는 동작을 수행 시 유용하게 활용할 수 있다. `main()` 메서드는 모든 비데몬 스레드가 종료딜 때까지 프로그램을 종료하지 않고 기다린다.

#### 15.2 동기 API와 비동기 API
* 메서드들을 별도의 스레드를 통해 실행하려면 `ExecutorService`의 `submit` 호출과 같은 불필요한 코드가 늘어난다.
    * 이러한 문제는 비동기 API 기능을 이용해 해결할 수 있다.

##### 15.2.1 Future 형식 API
```java
Future<Integer> y = f(x);
Future<Integer> z = g(x);
```
* `Future`를 반환하는 메서드는 호출 즉시 자신의 원래 바디를 평가하는 태스크를 포함하는 `Future`를 반환한다.
* `get`을 이용해 `Future`가 완료된 결과를 얻을 수 있다.

##### 15.2.2 리액티브 형식 API
* 함수의 시그니처를 바꿔 콜백 형식의 프로그래밍을 이용할 수 있다.
```java
void f(int x, IntConsumer dealWithResult);
```
* 추가 인수로 콜백(람다)을 전달해서 함수 바디에서는 `return`문으로 결과를 반환하는 것이 아니라 결과가 준비되면 이를 람다로 호출하는 태스크를 만든다.
* 함수는 바디를 실행하면서 태스크를 만든 다음 즉시 반환하므로 코드 형식이 아래와 같이 바뀐다.

```java
public class CallbackStyleExample {
    public static void main(String[] args) {

        int x = 1337;
        Result result = new Result();
        
        f(x, (int y) -> {
            result.left = y;
            System.out.println((result.left + result.right));
        });

        g(x, (int z) -> {
            result.right = z;
            System.out.println((result.left + result.right));
        })
    }
}
```
* 위의 경우 락을 사용하지 않으므로 값을 두 번 출력하거나 피연산자가 출력 전에 업데이트될 수 있다.
    * `if-then-else`를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 출력문을 호출한다.
    * 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 `Future`를 이용한다.
* `Future`는 한 번만 완료되며 그 결과는 `get`으로 얻을 수 있다. 리액티브 형식의 비동기 API는 자연스럽게 일련의 값을, `Future` 형식의 API는 일회성의 값을 처리하는 데에 적합하다.

##### 15.2.3 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주
* 스레드는 잠들어도 시스템 자원을 점유하므로 스레드의 수가 늘고 대부분이 잠을 잔다면 성능이 저하된다.
* 스레드 풀에서 잠을 자는 태스크(혹은 블록 동작을 하는 태스크)는 다른 태스크가 시작되지 못하게 막고 자원을 소비한다. 운영체제가 이들 태스크를 관리하므로 일단 스레드로 할당된 태스크는 중지시키지 못한다.
    * 태스크를 만들 때는 태스크가 실행되면 자원을 점유하므로 태스크가 끝나서 자우너을 해제하기 전까지 태스크를 계속 실행해야 함을 명심한다. 
    * 태스크를 블록하는 것보다는 다음 작업을 태스크로 제출하고 현재 태스크는 종료하는 것이 바람직하다.

##### 15.2.4 현실성 확인
* 현실에서는 모두 비동기로 처리하디보다는 개선된 동시성 API를 이용해 유익을 얻을 수 있는 상황을 찾아보고 적용해 보는 방안도 고려되어야 한다.

##### 15.2.5 비동기 API에서 예외는 어떻게 처리되는가?
* `Future`나 리액티브 형식의 비동기 API에서 호출된 메서드의 실제 바디는 별도의 스레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의 실행 범위와는 관계 없는 상황이 된다.
* 예상치 못한 일이 일어나면 예외를 발생시켜 다른 동작이 실행될 수 있도록 `CompletableFuture`에서는 `exceptionally` 같은 메서드 등을 제공한다.
* 리액티브 형식의 비동기 API에서는 `return` 대신 기존 콜백이 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야 한다.
    * 콜백이 여러 개면 이를 따로 제공하는 것보다는 한 객체로 이 메서드를 감싸는 것이 좋다. 예를 들어 자바 9 플로 API에서는 여러 콜백을 한 객체로 감싼다.
* 일련의 데이터를 만들어내고 더 이상 처리할 것이 없음을 나타내는 알림 등을 나타내는 종류의 호출을 메시지 또는 이벤트라 부른다.
    * 이런 이벤트를 API의 일부로 보자면 API는 이벤트의 순서(채널 프로토콜이라 불리는)에는 전혀 개의치 않는다.

#### 15.3 박스와 채널 모델
* 동시성 모델을 가장 잘 설계하고 개념화하는 방법에는 박스와 채널 모델이 있다.
![](https://user-images.githubusercontent.com/55083845/158386166-870fc636-56c2-4769-9462-29439fd6e730.jpeg)
```java
int t = p(x);
System.out.println(r(q1(t), q2(t)));
```
```java
int t = p(x);
Future<Integer> a1 = executorService.submit(() -> q1(t));
Future<Integer> a2 = executorService.submit(() -> q2(t));
System.out.println(r(a1.get(), a2.get()));
```
* 시스템이 커지고 각각의 박스와 채널 다이어그램이 등장하고 각각의 박스는 내부적으로 자신만의 박스와 채널을 사용하면 많은 태스크가 `get()` 메서드를 호출해 `Future`가 끝나기를 기다리는 상태에 놓일 수 있다.
    * 결과적으로 하드웨어의 병렬성을 제대로 활용하지 못하거나 데드락에 걸릴 수 있다.
* 자바 8에서는 `CompletableFuture`와 콤비네이터를 이용해 문제를 해결한다.
* 박스와 채널 모델로 대규모 시스템 구현의 추상화 수준을 높일 수 있다. 박스 또는 프로그램의 콤비네이터로 원하는 연산을 표현하면 계산을 손으로 코딩한 결과보다 더 효율적일 것이다.
    * 콤비네이터는 수학적 함수뿐 아니라 `Future`와 리액티브 스트림 데이터에도 적용할 수 있다.
    * 박스와 채널 모델은 병렬성을 직접 프로그래밍하는 관점을 콤비네이터를 이용해 내부적으로 작업을 처리하는 관점으로 바꿔 준다.
    * 마찬가지로 자바 8 스트림은 자료 구조를 반복해야 하는 코드를 내부적으로 작업을 처리하는 스트림 콤비네이터로 바꿔 준다.

#### 15.4 CompletableFuture와 콤비네이터를 이용한 동시성
* `CompletableFuture`는 실행할 코드 없이 `Future`를 만들 수 있도록 허용하며 `complete()` 메서드를 이용해 나중에 어떤 값을 이용해 다른 스레드가 이를 완료할 수 있고 `get()`으로 값을 얻을 수 있도록 허용한다.
* `CompletableFuture<T>`에 `thenCombine` 메서드를 사용함으로써 두 연산 결과를 더 효과적으로 사용할 수 있다.
```java
CompletableFuture<V> thenCombine(CompletableFuture<U> other, BiFunction<T, U, V> fn)
```
* 이 메서드는 두 개의 `Completable` 값을 받아 한 개의 새 값을 만든다. 처음 두 작업이 끝나면 두 결과 모두에 fn을 적용하고 블록하지 않은 상태로 결과 `Future`를 반환한다.
* 두 `Future`의 결과를 알지 못하는 상황에서 `thenCombine`은 두 연산ㄷ이 끝났을 때 스레드 풀에서 실행된 연산을 만든다. 결과를 추가하는 세 번째 연산은 다른 두 작업이 끝날 때까지는 스레드에서 실행되지 않는다. (먼저 시작해서 블록되지 않는다.)
* 상황에 따라서는 `get`을 기다리는 스레드가 큰 문제가 되지 않으므로 기존 `Future`를 이용할 수도 있으나 어떤 상황에서는 많은 수의 `Future`를 사용해야 하므로 `CompletableFuture`와 콤비네이터를 이용해 `get`에서 블록하지 않고 병렬 실행희 효율성을 높이면서 데드락은 피하는 해결책을 구현할 수 있다.

#### 15.5 발행-구독 그리고 리액티브 프로그래밍
* 리액티브 프로그래밍은 여러 번의 결과를 필요로 하며 가장 최근의 결과가 중요하다. 결과에 대해 반응하는 부분이 존재하기 때문이다.
    * 스트림은 한 번의 단말 동작으로 소비될 수 있으며 두 개의 파이프라인으로 값을 분리하기 어렵고, 두 개로 분리된 스트림에서 다시 결과를 합치기도 어렵다. 즉, 선형적인 파이프라인 처리 기법에 알맞다.
    * 자바 9에서는 `java.util.concurrent.Flow`의 인터페이스에 발행-구독 모델을 적용해 리액티브 프로그래밍을 제공한다.
* 자바 플로 API는 아래 세 가지로 간단히 정리할 수 있다.
    * **구독자**가 구독할 수 있는 **발행자**
    * 이 연결을 **구독**이라 한다.
    * 이 연결을 이용해 **메시지**(또는 **이벤트**로 알려짐)를 전송한다.

##### 15.5.1 두 플로를 합치는 예제
* 구독자를 인수로 받는 발행자 인터페이스를 만든다.
* 통신할 구독자 인터페이스는 정보를 전달하는 단순 메서드를 포함하는 메서드로, 구현자가 필요한 대로 구현 가능하다.
* 데이터가 발행자(생산자)에서 구독자(소비자)로 흐름에 착안해 개발자는 이를 업스트림 또는 다운스트림이라 부른다. 데이터는 업스트림 메서드로 전달되고 구독자에게 알리는 메서드 호출을 통해 다운스트림 메서드 호출로 전달된다.
    * 실생활에서 플로를 사용하기 위해서는 데이터 흐름에서 예외가 발생하거나 종료되었음을 알 수 있어야 한다.
* 수많은 메시지 전달되는 상황을 **압력**이라 한다.
    * 이를 제한하는 역압력 같은 기법이 필요하다. 자바 9 플로 API에서는 발행자가 무한의 속도로 아이템을 방출하는 대신 요청했을 때만 아이템을 보내도록 하는 메서드를 제공한다. (당김*pull* 모델)

##### 15.5.2 역압력
* 정보의 흐름 속도를 역압력(흐름 제어)으로 제어, 즉 `Subscriber`에서 `Publisher`로 정보를 요청해야 할 필요가 있을 수 있다.
    * 자바 9 플로 API의 구독자 인터페이스는 `void onSubscribe(Subscription subscription)` 메서드를 포함한다. 발행자와 구독자 사이에 채널이 연결되면 첫 이벤트로 이 메서드가 호출된다.
    * `Subscription` 객체는 구독자와 발행자와 통신할 수 있는 메서드(`cancel`, `request`)를 포함한다. 발행자가 객체를 만들어 구독자로 전달하면 구독자는 이를 이용해 발행자로 정보를 보낼 수 있다.

##### 15.53 실제 역압력의 간단한 형태
* 한 번에 한 개의 이벤트를 처리하도록 발행-구독을 연결을 구성하려면 다음과 같은 작업이 필요하다.
    * 구독자가 `onSubscribe`로 전달된 `Subscription` 객체를 `subscription` 같은 필드에 로컬로 저장한다.
    * 구독자가 수많은 이벤트를 받지 않도록 `onSubscribe`, `onNext`, `onError`의 마지막 동작에 `channel.request(1)`을 추가해 오직 한 이벤트만 요청한다.
    * 요청을 보낸 채널에만 `onNext`, `onError` 이벤트를 보내도록 발행자의 `notifyAllSubscribers` 코드를 바꾼다. (보통 여러 구독자가 자신만의 속도를 유지할 수 있도록 발행자는 새 `Subscription`을 만들어 각 구독자와 연결한다.)
* 고려해야 할 사항들은 다음과 같은 것들이 있다.
    * 여러 구독자가 있을 때 이벤트를 가장 느린 속도로 보낼 것인가? 아니면 각 구독자에게 보내지 않은 데이터를 저장할 별도의 큐를 가질 것인가?
    * 큐가 너무 커지면 어떻게 해야 할까?
    * 구독자가 준비가 안 되었다면 큐의 데이터를 폐기할 것인가?
* 이 기법에서는 구독자가 발행자로부터 요청을 당긴다는 의미에서 리액티브 당김 기반이라 불린다. 이런 방식으로 역압력을 구현할 수도 있다.

#### 15.6 리액티브 시스템 vs 리액티브 프로그래밍
* 리액티브 시스템은 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 프로그램을 가리킨다.
    * 반응성, 회복성, 탄력성으로 세 가지 속성을 요약할 수 있다.
    * 반응성은 리액티브 시스템이 큰 작업을 처리하느라 간단한 질의의 응답을 지연하지 않고 실시간으로 입력에 반응하는 것을 의미한다.
    * 회복성은 한 컴포넌트의 실패로 전체 시스템이 실패하지 않음을 의미한다.
    * 탄력성은 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을 의미한다.
* 여러 방법으로 이런 속성을 구현할 수 있지만 자바 인터페이스에서 제공하는 리액티브 프로그래밍 형식을 이용하는 것도 방법이다.
    * 이들 인터페이스 설계는 Reactive Manifesto의 네 번째이자 마지막 속성, 즉 메시지 주도 속성을 반영한다.
    * 메시지 주도 시스템은 박스와 채널 모델에 기반한 내부 API를 갖고 있는데 여기서 컴포넌트는 처리할 입력을 기다리고 결과를 다른 컴포넌트로 보내면서 시스템이 반응한다.