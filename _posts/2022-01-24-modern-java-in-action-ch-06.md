---
title: "Modern Java in Action 6장; 스트림으로 데이터 수집"
categories:
  - Language
tags:
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 6. 스트림으로 데이터 수집

#### 6.1 컬렉터란 무엇인가?
* `Collector` 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.

##### 6.1.1 고급 리듀싱 기능을 수행하는 컬렉터
* 스트림에 `collect`를 호출하면 스트림의 요소에 (컬렉터로 파라미터화된) 리듀싱 연산이 수행된다. 리듀싱 연산을 이용해 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다.

##### 6.1.2 미리 정의된 컬렉터
* `Collectors`에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.
  * 스트림의 요소를 하나의 값으로 리듀스하고 요약
  * 요소 그룹화
  * 요소 분할

#### 6.2 리듀싱과 요약

##### 6.2.1 스트림값에서 최댓값과 최솟값 검색
* `Collectors.maxBy`, `Collectors.minBy`를 사용한다.
  * 두 컬렉터는 스트림의 요소를 비교하는 데에 사용할 `Comparator`를 인수로 받는다.
* 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용되는데, 이러한 연산을 **요약** 연산이라 부른다.

##### 6.2. 2 요약 연산
* `Collectors` 클래스는 `Collectors.summingInt`라는 특별한 요약 팩토리 메서드를 제공한다. (`Long`, `Double`도 존재)
* 이러한 단순 합계 외에 `Collectors.averagingInt` 등의 연산도 요약 기능으로 제공된다.
* 두 개 이상의 연ㅅ나을 한 번에 수행해야 하는 경우 팩토리 메서드 `summarizingInt`가 반환하는 컬렉터를 사용할 수 있다.

##### 6.2.3 문자열 연결
* 컬렉터에 `joining` 팩토리 메서드를 이용하면 스트림의 각 객체에 `toString` 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.
  * 내부적으로 `StringBuilder`를 이용해 문자열을 하나로 만든다.

##### 6.2.4 범용 리듀싱 요약 연산
* 위의 모든 컬렉터는 `reducing` 팩토리 메서드로 정의할 수 있지만 특화된 컬렉터를 사용하면 프로그래밍적 편의성을 얻을 수 있다. 이 메서드는 인수 세 개를 받는다.
  * 첫 번째는 리듀싱 연산의 시작값이거나 스트림에 인수가 없을 때는 반환값이다.
  * 두 번째는 객체에서 필요한 정수를 얻는 등에 쓰는 변환 함수이다.
  * 세 번째는 같은 종류의 두 항목을 하나의 값으로 더하는 `BinaryOperator`다.
* 한 개의 인수를 갖는 `reducing`은 세 개의 인수를 갖는 것에서 스트림의 첫 번째 요소를 시작 요소, 즉 첫 번째 인수로 받으며 자신을 그대로 반환하는 항등 함수를 두 번째 인수로 받는 상황에 해당한다.
* `collect` 메서드는 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계된 메서드인 반면 `reduce`는 두 값을 하나로 도출하는 불변형 연산이라는 의미 차이가 있다.
* 함수형 프로그래밍에서는 하나의 연산을 다양한 방법으로 해결할 수 있으므로 가장 일반적으로 문제에 특화된 해결책을 고르는 게 바람직하다.

#### 6.3 그룹화
* `Collectors.groupingBy`로 그룹화가 가능하다. 이 메서드는 스트림을 그룹화하는 **분류 함수**를 받는다. 그룹화 함수가 반환하는 값을 이용해 그룹화 연산의 결과를 얻는다.

##### 6.3.1 그룹화된 요소 조작
* `groupingBy` 메서드가 두 번째 인수를 갖도록 오버로드된 것을 이용해서 그룹화된 요소를 조작할 수 있다. 두 번째 인수로 필터 프레디케이트를 적용할 수 있다.
  * `filtering` 메서드는 `Collectors` 클래스의 또 다른 팩도리 메서드로 프레디케이트를 인수로 받는다. 이 프레디케이트로 각 그룹의 요소와 필터링된 요소를 재그룹화한다.
  * 또 매핑 함수와 각 항목에 적용한 함수를 모으는데 사용하는 또 다른 컬렉터를 인수로 받는 `mapping` 메서드도 있다. `menu.stream().collect(groupingBy(Dish::getType), mapping(getName, toList))));`
  * 두 수준의 리스트를 한 수준으로 평면화하기 위해 `flatMapping` 메서드를 사용할 수 있다.

##### 6.3.2 다수준 그룹화
* 두 인수를 받는 `groupingBy`로 항목을 다수준으로 그룹화할 수 있다. 이 메서드는 일반적인 분류 함수와 컬렉터를 인수로 받는다. 즉, 바깥쪽 `groupingBy` 메서드에 스트림의 항목을 분류할 두 번째 기준을 정의하는 내부 `groupingBy`를 전달해서 두 수준으로 항목을 그룹화할 수 있다.


##### 6.3.3 서브그룹으로 데이터 수집
* `Collectors.collectingAndThen`으로 컬렉터가 반환한 결과를 다른 형식으로 활용할 수 있다.
  * 이 메서드는 적용할 컬렉터와 변환 함수를 인수로 받아 다른 컬렉터를 반환한다. 반환되는 컬렉터는 기존 컬렉터의 래퍼 역할을 하며 `collect`의 마지막 과정에서 변환 함수로 자신이 반환하는 값을 매핑한다.
```java
Map<Dish.Type, Dish> mostCaloriesByType = 
    menu.stream()
        .collect(grouptingBy(Dish::getType,
                 collectingAndThen(
                     maxBy(comparingInt(Dish::getCalories)),
                 Optional::get)));
```
![](https://user-images.githubusercontent.com/55083845/150966845-7fe809f2-cf42-4082-b7e9-ad91cec24818.jpeg)
* 이 외에도 `mapping` 메서드도 만들어진 컬렉터도 `groupingBy` 메서드와 자주 사용된다. `mapping` 메서드는 스트림의 인수를 변환하는 함수와 변환 함수의 결과 객체를 누적하는 컬렉터를 인수로 받는다. `mapping`은 입력 요소를 누적하기 전에 매핑 함수를 적용해서 다양한 형식의 객체를 주어진 형식의 컬렉터에 맞게 변환하는 역할을 한다.

#### 6.4 분할
* 분할은 분할 함수로 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다. `partitionBy` 메서드를 사용한다.

##### 6.4.1 분할의 장점
* 분할 함수가 반환하는 *참, 거짓* 두 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점이다.
  * 분할 함수는 불리언을 반환하므로 맵의 키 형식은 `Boolean`이다.
* 컬렉터를 두 번째 인수로 전달할 수 있는 오버로드된 버전도 존재한다.


#### 6.5 Collector 인터페이스
* `Collector` 인터페이스는 리듀싱 연산(즉, 컬렉터)을 어떻게 구현할지 제공하는 메서드 집합으로 구성된다.
```java
public interface Collector<T, A, R> {
  Supplier<A> supplier();
  BiConsumer<A, T> accumulator();
  Function<A, R> finisher();
  BinaryOperator<A> combiner();
  Set<Characteristics> characteristics();
}
```
* `T`는 수집될 스트림 항목의 제네릭 형식이다.
* `A`는 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식이다.
* `R`은 수집 연산 결과 객체의 형식(항상 그런 것은 아니지만 대개 컬렉션 형식)이다.

##### 6.5.1 Collector 인터페이스의 메서드 살펴보기
###### supplier 메서드: 새로운 결과 컨테이너 만들기
* 빈 결과로 이루어진 `Supplier`를 반환해야 한다. `supplier`는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다.

###### accumulator 메서드: 결과 컨테이너에 요소 추가하기
* 리듀싱 연산을 수행하는 함수를 반환한다. 스트림에서 n번째 요소를 탐색할 때 두 인수, 즉 누적자(스트림의 첫 n-1개 항목을 수집한 상태)와 n번째 요소를 함수에 적용한다.
* 함수의 반환값은 `void`, 즉 요소를 탐색하면서 적용하는 함수에 의해 누적자 내부 상태가 바뀌므로 누적자가 어떤 값일지 단정할 수 없다.

###### finisher 메서드: 최종 반환값을 결과 컨테이너로 적용하기
* 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 반환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다.

###### combiner 메서드: 두 결과 컨테이너 병합
* 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다. 
* 스트림의 리듀싱을 병렬로 수행할 수 있다. 스트림의 리듀싱을 병렬로 수행할 때 자바 7의 포크/조인 프레임워크과 `Spliterator`를 사용한다.
  * 스트림을 분할해야 하는지 정의하는 조건이 거짓으로 바뀌기 전까지 원래 스트림을 재귀적으로 분할한다. (보통 분산된 작업의 크기가 너무 작아지면 병렬 수행의 속도는 순차 수행의 속도보다 느려진다. 일반적으로 프로세싱 코어의 개수를 초과하는 병렬 작업은 효율적이지 않다.)
  * 모든 서브스트림의 각 요소에 리듀싱 연산을 순차적으로 적용해서 서브스트림을 병렬로 처리할 수 있다.
  * 마지막에는 컬렉터의 `combiner` 메서드가 반환하는 함수로 모든 부분결과를 쌍으로 합친다.

###### Characteristic 메서드
* 스트림을 병렬로 리듀스할 것인지 그리고 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트를 제공한다. 다음 세 항목을 포함하는 열거형이다.
  * `UNORDERED`: 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않는다.
  * `CONCURRENT`: 다중 스레드에서 `accumulator` 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있다. `UNORDERED`를 함께 설정하지 않았다면 데이터 소스가 정렬되어 있지 않은(요소의 순서가 무의미한) 상황에서만 병렬 리듀싱을 수행할 수 있다.
  * `IDENTITY_FINISH`: `finisher` 메서드가 반환하는 함수는 단순히 `identity`를 적용할 뿐이므로 생략할 수 있다. 따라서 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있다. 또한 누적자 A를 결과 R로 안전하게 형변환할 수 있다.

##### 6.5.2 응용하기
```java
public class ToListCollector<T> implements Collector<T, List<T>, List<T>> {
  @Override
  public Supplier<List<T>> supplier() {
    return ArrayList::new; // 수집 연산의 시작점
  }

  @Override
  public BiConsumer<List<T>, T> accumulator() {
    return List::add; // 탐색한 항목을 누적하고 바로 누적자를 고친다
  }

  @Override
  public Function<List<T>, List<T>> finisher() {
    return Function.identity(); // 항등 함수
  }

  @Override
  public BinaryOperator<List<T>> combiner() {
    return (list1, list2) -> {
      list1.addAll(list2); // 두 번째 콘텐츠와 합쳐서 첫 번째 누적자를 고친다
      return list1; // 변경된 첫 번째 누적자를 반환한다
    }
  }
}
``` 
* `IDENTITY_FINISH` 수집 연산에서는 `Collector` 인터페이스를 완전히 새로 구현하지 않고도 같은 결과를 얻을 수 있다. `Stream`은 세 함수(발행, 누적, 합침)를 인수로 받는 `collect` 메서드를 오버로드하며 각각의 메서드는 `Collector` 인터페이스의 메서드가 반환하는 함수와 같은 기능을 수행한다.
  * `Characteristics`를 전달할 수 없다. `IDENTITY_FINISH`와 `CONCURRENT`지만 `UNORDERED`는 아닌 컬렉터로만 동작한다.


#### 6.6 커스텀 컬렉터를 구현해서 성능 개선하기

##### 6.6.1 소수로만 나누기

###### 1단계: Collector 클래스 시그니처 정의
* `Collector` 인터페이스 정의를 참고해서 클래스 시그니처를 만든다.

###### 2단계: 리듀싱 연산 구현
* `Collector` 인터페이스에 선언된 다섯 메서드를 구현해야 한다. `supplier` 메서드는 누적자를 만드는 함수를 반환해야 한다.
* 스트림의 요소를 어떻게 수집할지 결정하는 것은 `accumulator` 메서드로 최적화의 핵심이기도 하다.

###### 3단계: 병렬 실행할 수 있는 컬렉터 만들기(가능하다면)
* 병렬 수접 과정에서 두 부분 누적자를 합칠 수 있는 메서드를 만든다.
* `combiner`는 병렬 실행이 불가할 경우 빈 구현으로 남겨 두거나 `UnsupportedOperationException`을 던지도록 구현할 수 있다.

###### 4단계: finisher 메서드와 characteristics 메서드
* `accumulator`의 형식이 컬렉터 결과 형식과 같은 경우 변환 과정이 필요 없으므로 `identity`를 반환하도록 할 수 있다. 다른 경우 그에 맞는 함수를 반환하게 한다.
* 커스텀 컬렉터는 `CONCURRENT`도 아니고 `UNORDERED`도 아니지만 `IDENTITY_FINISH`이므로 `characteristics` 메서드를 구현할 수 있다.

* `Collector` 인터페이스를 구현하는 새 클래스를 만드는 대신 발행, 누적, 합침 함수를 `collect`에 직접 전달할 수도 있다. 이 경우 결과 코드는 간결하지만 가독성과 재사용성이 떨어진다.