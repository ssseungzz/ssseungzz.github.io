---
title: "Modern Java in Action 18장; 함수형 관점으로 생각하기"
categories:
  - Language
tags:
  - java
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 18. 함수형 관점으로 생각하기
#### 18.1 시스템 구현과 유지 보수
* 많은 프로그래머들은 변숫값의 변화로 인한 코드 크래시 디버깅 문제를 많이 겪는다.
* 함수형 프로그래밍이 제공하는 부작용 없음과 불변성이라는 개념이 이 문제를 해결하는 데에 도움을 준다.

##### 18.1.1 공유된 가변 데이터
* 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.
* 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 `return` 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 **부작용 없는** 메서드라고 부른다.
* 함수 내에 포함되지 못한 기능을 부작용이라고 한다.
  * 자료구조를 고치거나 필드에 값을 할당(`setter` 메서드 같은 생성자 이외의 초기화 동작)
  * 예외 발생
  * 파일에 쓰기 등의 I/O 동작 수행
* 불변 객체를 이용해서 부작용을 없애는 방법도 있다. 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.
* 부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었고, 함수형 프로그래밍은 선언형 프로그래밍에 기반한다.

##### 18.1.2 선언형 프로그래밍
* '어떻게'에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식으로 명령형 프로그래밍이라고 부르기도 한다. 할당, 조건문, 분기문, 루프 등을 이용한다.
* 질의문 구현 방식은 라이브러리가 결정하며 '무엇을'에 집중하는 구현 방식을 내부 반복이라고 한다. 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여 준다는 것이 내부 반복 프로그래밍의 큰 장점이며, 이처럼 '무엇을'에 집중하는 방식을 선언형 프로그래밍이라고 부른다.

##### 18.1.3 왜 함수형 프로그래밍인가?
* 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용이 없는 계산을 지향한다.
* 선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데에 도움을 준다.

#### 18.2 함수형 프로그래밍이란 무엇인가?
* 함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 즉, 0개 이상의 인수를 가지며 한 개 이상의 결과를 반환하지만 부작용이 없어야 한다.
* 함수형이라는 말은 수학의 함수처럼 부작용이 없는 것을 의미한다.
  * 호출자에 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경 쓸 필요가 없다.
  * 함수 그리고 if-then-else 등의 수학적 표현만 사용하는 방식을 순수 함수형 프로그래밍이라고 하며, 시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용하는 방식을 함수형 프로그래밍이라고 한다.

##### 18.2.1 함수형 자바
* 실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵기 때문에 함수형 프로그램을 구현한다.
* 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉, 객체의 모든 필드가 `final`이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.
  * 단 특정 조건을 만족하는 하에 예외적으로 메서드 내에서 생성한 객체의 필드는 갱신 가능하다.
* 또한 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
  * 수학적 함수는 주어진 인수값에 대응하는 하나의 결과를 반환한다. 실제 대부분의 수학 연산은 부분 함수로 활용된다. 어떤 입력값이 있을 때 이는 정확하게 하나로 도출되지만 입력값이 undefined라면 결과가 아예 나오지 않는다. 이때, 예외를 처리하는 과정에서 함수형에 위배되는 제어 흐름이 발생하는 걸 해결하기 위해 `Optional`을 사용할 수 있다.
* 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.

##### 18.2.2 참조 투명성
* 부작용을 감춰야 한다는 제약은 참조 투명성 개념으로 귀결된다. 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
* 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.
* 참조 투명성은 프로그램 이해에 큰 도움을 주며 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.
* 자바에서 `List`를 반환하는 메서드를 두 번 호출한다고 가정할 때, 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.
  * 결과 리스트가 가변 객체라면 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나온다.
  * 결과 리스트를 불변의 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다. 일반적으로 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.

##### 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍
* 프로그래밍 형식의 스펙트럼 한 쪽 끝에는 모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메서드를 호출하고, 관련 객체를 갱신하는 방식으로 동작하는 익스트림 객체지향 방식이 위치하며 반대쪽에는 참조적 투명성을 중시하여 변화를 허용하지 않는 함수형 프로그래밍 형식이 위치한다.

##### 18.2.4 함수형 실전 연습
* 리스트의 모든 부분 집합 리스트로 구성된 리스트를 구하는 프로그램을 가정한다.
```java
static List<List<Integer>> subsets(List<Integer> list) {
  if (list.isEmpty()) {
    List<List<Integer>> ans = new ArrayList<>();
    ans.add(Collections.emptyList());
    return ans;
  }

  Integer first = list.get(0);
  List<Integer> rest = list.sublist(1, list.size());

  List<List<Integer>> subans = subsets(rest);
  List<List<Integer>> subans = insertAll(first, subans);
  return concat(subans, subans2);
}
```

```java
static List<List<Integer>> insertAll(Integer first, List<List<Integer>> lists) {
  List<List<Integer>> result = new ArrayList<>();
  for (List<Integer> list : lists) {
    List<Integer> copyList = new ArrayList<>(); // 리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다. 구조체가 가변이더라도 저수준 구조를 복사하진 않는다.
    copyList.add(first);
    copyList.addAll(list);
    result.add(copyList)
  }
  return result;
}
```
```java
static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
  List<List<Integer>> r = new ArrayList<>(a);
  r.addAll(b);
  return r;
}
```

* 내부에 리스트를 복사하는 코드를 추가하면 반환 결과는 오로지 인수에 의해 이루어지며 인수의 정보는 변경하지 않으므로 순수 함수라고 할 수 있다.

#### 18.3 재귀와 반복
* 루프 내부에서 프로그램의 다른 부분과 공유되는 객체의 상태를 변화시키는 부작용이 발생할 수 있다.
  * 이러한 문제 때문에 순수 함수형 프로그래밍 언어에서는 부작용 연산을 원칙적으로 제거했다.
  * 이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다. 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다.
* 그러나 일반적으로 함수를 호출할 때마다 호출 스태겡 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어지므로, 재귀는 입력값에 비례하여 메모리 사용양이 증가한다. 즉, 코드가 더 비싸진다.
  * 함수형 언어에서는 꼬리 호출 최적화라는 해결책을 제공한다. 중간 결과를 각각의 스택 프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다.
  * 자바에서는 이와 같은 최적화를 제공하지는 않지만 그럼에도 컴파일러 최적화 여지를 남겨 둘 수 있는 꼬리 재귀를 적용하는 것이 좋다.

![](https://user-images.githubusercontent.com/55083845/160620178-9de0dd72-d60d-4ef5-86c6-936af8da54f6.jpg)

* 결론적으로 자바 8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다. 또한 반복을 재귀로 바꾸면 더 간결하고, 부작요 없는 알고리즘을 만들 수 있다.