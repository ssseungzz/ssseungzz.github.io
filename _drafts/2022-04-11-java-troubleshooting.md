---
title: "자바 트러블슈팅 - 스레드 때문에 발생하는 문제들"
categories:
  - Operation
tags: 
toc: true
toc_label: "Contents"
toc_sticky: true
---

## 자바 트러블슈팅 - 스레드 때문에 발생하는 문제들

### Ch 9. 스레드 단면 잘라 놓기
* 스레드상의 점유 문제가 발생했을 경우 유용하게 사용할 수 있다.

#### 스레드 단면(스레드 덤프) 해부하기

* 스레드 단면 생성 시간 정보: `YYYY-MM-DD HH:MM:SS` 와 같은 형태로 덤프를 생성한 날짜와 시간 정보를 출력한다.

* JVM에 대한 정보: JVM에 대한 종류와 상태, 버전 등에 대한 정보를 출력한다.

```text
Full thread dump Java HotSpot(TM) Client VM (11.2-b01 moxed mode, sharing):
```

* 각 스레드의 스택을 포함한 다양한 정보
    * 첫 줄에 있는 항목은 다음과 같다.
    1. 스레드 이름
    2. 식별자: 데몬 스레드일 경우에만 표시된다.
    3. 스레드 우선순위(prio): 가장 낮은 것이 1, 가장 높은 것이 10
    4. 스레드 ID(tid): 해당 스레드가 점유하는 메모리의 주소
    5. 네이티브 스레드 ID(nid): OS에서 관리하는 스레드의 ID
    6. 스레드의 상태
    7. 주소 범위: 스택 영역의 예상된 주소 범위

    * 스레드의 상태는 여섯 개로 나뉜다.
        * `NEW`: 스레드가 아직 시작되지 않은 상태
        * `RUNNABLE`: 스레드가 수행 중인 상태
        * `BLOCKED`: 스레드가 잠겨 있어 풀리기를 기타리는 상태
        * `WAITING`: 다른 스레드가 특정 작업을 수행하여 깨울 때까지 무한정 기다리는 상태
        * `TIMED_WAITING`: 다른 스레드가 특정 작업을 수행하여 깨울 때까지 지정된 시간만큼 기다리고 있는 상태
        * `TERMINATED`: 스레드가 종료된 상태

```text
"Thread-0" prio=6 tid=0x02b1ec00 nid=0xcd8 runnable [0x02eb30e2..0x02ek6fd02]
   java.lang.Thread.State:  RUNNABLE
        at java.util.HashMap.resize(HashMap.java:462)
...
```


* 데드록에 대한 정보: 데드록이 발생했을 경우에만 출력된다. 어떤 스레드들이 서려 물고 물리는 관계가 되었는지에 대한 정보와 자바 레벨에 명시된 데드록 상태에 있는 스레드들의 스택 정보를 제공한다.

```text
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x34253kf1 (object 0x15436lm3, a Deadlock$Friend),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x34253he1 (object 0x15426jmk, a Deadlock$Friend),
  which is held by "Thread-1"
Java stack information for the threads listed above:
"Thread-1":
        at Deadlock$Friend.bowBack(Deadlock.java:17)
...
```

* 힙 영역의 사용 현황: GC 방식에 따라 보여지는 영역의 이름이 조금씩 다르며 각 영역별로 한 줄씩 출력된다. 순서대로 다음과 같은 내용으로 이루어져 있다.
    * 영역 이름
    * 영역에 할당된 메모리의 크기
    * 메모리 사용량(혹은 비율)
    * 메모리의 영역 정보(range)

```text
Heap
 def new generation     total 960K, used 510K [0x229e0000, 0x22ae0000, 0x22ec0000)
   eden space 896K,     92% used [0x229e0000, 0x22ab2298, 0x22ac0000)
   from space 64K,      18% used [0x22ad0000, 0x22ad3038, 0x22ae0000]
   to   space 64K,       0% used [0x22ac0000, 0x22ac0000, 0x22ad0000)
 tenured generation     total 4096K, used 142K [0x22ec0000, 0x232c0000, 0x269e0000)
...
```

* 자바는 기본적으로 JVM이 시작하면 GC 처리하는 스레드, 컴파일 담당 스레드 등 여러 스레드 등을 자동으로 수행햔다. 
* 옵션을 추가하면 추가적인 스레드 정보를 얻을 수 있다. (ex - `java -XX:+PrintConcurrentLocks`)


#### 가장 간편한 Ctrl+Break와 Kill -Quit
* 리눅스에서 스레드 단면을 생성하기 위해서는 `kill -3 pid` 명령을 사용한다. OS에 따라 QUIT를 의미하는 옵션이 3이 아닐 수 있으므로 `man kill`로 확인한 뒤 사용한다.
    * 이 옵션을 사용하지 않으면 프로세스가 사라질 수 있다.
* 스레드 단면을 파일로 남기려면 `nohub java MakeThreads > MakeThreadResult.txt &`과 같이 일반적으로 `nohub`, `&`를 자주 사용한다.

### 10. 잘라 놓은 스레드 단면 분석하기

#### ThreadLogic 준비하기
* 스레드 단면 파일을 열어 분석할 수 있다.

#### ThreadLogic 사용하기
* 록이 발생하면 빨간색으로 표시되는데, 한두 개의 록으로는 표시되지 않으므로 스레드 단면 하나만 분석해서는 안 된다.
* 무한 루프나 DB 등에서 응답하지 않는 경우 하나의 스레드를 지속해서 점유하지만 전자는 CPU를 풀로 점유한다. 후자는 대기하게 되는데 이 경우 CPU를 점유하지는 않지만 실행 중 상태가 유지되어 스레드가 부족해지거나 DB Connection Pool에 가용한 연결이 부족해지는 등의 문제가 발생한다.
* `ps -LF` 명령어로 자바 프로세스, 스레드에 대한 정보를 얻고 이를 ThreadLogic에서 활용할 수 있다. 이 명령어가 제공하는 항목은 아래와 같다.
    * UID: 사용자 id
    * PID: 프로세스 id
    * PPID: 부모 프로세스 id
    * LWP: Light Weight Process의 약자로 스레드의 id
    * C: 해당 프로세스가 지속해서 사용한 CPI 사용량
    * NLWP: 해당 프로세스에서 사용하는 스레드의 수
    * STIME: 프로세스가 시작한 시간
    * TIME: CPU 점유 시간
    * CMD: 프로세스를 수행시킨 명령어


### 11. 스레드 문제 Case Study

#### 시스템이 느릴 때도 스레드와 관련이 있을까?
* 생성해 놓으면 근거를 찾는 데에는 도움이 된다. 다음과 같은 순서로 점검하는 것이 좋다.
  1. CPU, 메모리와 같은 리소스 사용량 점검
  2. 외부와 연동하는 리소스 사용량 점검
  3. WAS 메모리 및 스레드 설정 및 사용량 점검
  4. Web 서버 설정 점검
  5. OS 설정 점검
  6. 스레드 상태 점검
  7. 메모리 상태 점검

#### 시스템 응답이 없을 때에는 스레드 단면이 가장 효과적이다
* 보통 WAS가 정해 놓은 스레드 풀이나 DB 커넥션 풀이 꽉 찼을 확률이 높아 스레드 단면이 효과를 발휘하기 좋다.
  1. 전체 스레드의 개수를 확인한다.
  2. 스레드 단면의 루트 노드를 클릭하여 메모리 사용량을 확인해 보고, 여러 개의 단면 파일을 비교해 가며 그 값이 어떻게 변하는지 확인해 본다.
  3. (Monitor 목록에서 빨간색으로 표시되는 등) 여러 스레드를 잡는 경우가 없는지 찾아본다.
  4. 1에 해당하는 스레드가 보이지 ㅇ낳을 때에는 Runnable인 스레드들을 살펴본다.
  5. 지속해서 수행 중인 스레드가 존재하지 않는지 확인한다.
  6. 그래도 원인이 없어 보이면 다른 원인을 찾아본다. (웹 서버 설정, JVM 힙 메모리 부족 등)
* 메모리가 부족한 경우 GC 관련 스레드가 실행 중인 상태면서 CPU 코어를 하나 이상 100% 점유하고 나머지 모든 스레드는 아무 작업을 하지 않을 수 있다. 이 상황에서는 아래와 같이 분석할 수 있다.
  1. 스레드 단면을 주기적으로 떠 놓는다.
  2. 단면 뜰 때 `ps -Lf -p pid` 명령어도 같이 수행하여 주기적으로 떠 놓는다.
  3. 2에서 점검한 스레드 중 CPU 사용 시간이 지속해서 증가하는 스레드가 있다면 그 스레드의 아이디를 확인한 후 스레드 단면 분석 도구를 활용해 방금 만든 스레드 단면에서 해당 스레드가 어떤 스레드인지 확인한다.
  4. 3의 스레드가 GC 관련 스레드라면 메모리가 부족하거나 GC 알고리즘 문제일 확률이 높다. `jstat`으로 메모리 사용량을 확인하고 어떤 객체가 메모리를 많이 잡고 있는지 확인한다.
  5. GC 관련 스레드가 아니라면 해당 스레드가 지속해서 수행되고 있는지 확인한다.

#### 예외가 지속해서 발생할 때도 스레드 단면이 도움이 될까?
* 애플리케이션 코딩상의 실수 등일 확률이 높으므로 자바 로그가 도움이 좋은 단서가 될 수 있다.
* `TimeOutException` 등이 자주 찍히는 경우 DB 쿼리, GC 처리, 연동되어 있는 시스템의 응답 지연 등이 원인일 수 있으므로 해당 부분을 점검해 본다.

#### 사례 하나. CPU 사용량이 갑자기 올라가서 안 내려오는 경우
* 각 CPU가 어떻게 점유하는지를 확인한다. 특정 코어의 사용량이 급증하는 경우 아래와 같은 원인이 있을 수 있다.
  * 애플리케이션 로직상의 잘못으로 무한 루프
  * 정규 표현식의 잘못된 사용으로 인한 무한 루프
  * 메모리가 부족하여 GC 관련 스레드만 반복적으로 수행(CPU 코어 하나만을 점유할 가능성이 높음)
    1. 장애가 발생한 장비에서 스레드 덤프를 30초나 1분 간격으로 5~10회 정도 생성(`kill -3 pid`)
    2. 덤프 생성 시 각 스레드별 사용 시간에 대한 덤프 생성(`ps -Lf -p pid`)
    3. 스레드 단면 분석 도구로 덤프 파일 열기
    4. `ps` 명령어를 사용하여 수집한 덤프에서 수행 시간이 가장 오래 걸린 스레드 확인
    5. 스레드 단면 분석 도구에서 해당 스레드에서 어떤 작업을 하고 있는지 스택 정보 확인
    6. 결과 공유
  

#### 사레 둘. 스레드 풀의 스레드 개수 증가
* 주기적으로 여러 번 스레드 덤프를 뜨고 분석 도구를 통해 분석해 본다.
* 문제가 있어 보이는 스레드(대기 스레드 개수가 많은, 록을 발생시킨 스레드)의 스택 정보를 확인해 본다.

#### 사례 셋. 시스템 응답 없음
* 스레드 덤프와 `ps -Lf` 명령어로 어떤 스레드가 CPU를 계속 사용하고 있는지 확인한다.
* 스레드 단면 분석 도구를 활용해 해당 스레드들의 Native ID를 확인하고, 어떤 스레드인지 확인한다.
  *  GC 관련 스레드인 경우 메모리 릭이 문제일 가능성이 높다.
