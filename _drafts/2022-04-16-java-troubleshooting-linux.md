---
title: "자바 트러블슈팅 - 리눅스 진단하기"
categories:
  - Operation
tags: 
toc: true
toc_label: "Contents"
toc_sticky: true
---

## 리눅스 진단하기

### 17. 리눅스 성능 진단 도구의 구성

#### 60,000 밀리초에 리눅스 시스템 진단하기
* `uptime`: 서버가 시작한 지 얼마나 되는지를 확인하기 위한 명령어
* `dmesg | tail`: 최근 시스템 메시지 확인
* `vmstat 1`: 가상 메모리 상황 확인
    * `r`: CPU의 Run Queue, 코어 개수보다 많으면 서버가 바쁜 상황
    * `free`: KB 단위의 메모리 여유
    * `swap(si, so)`: 메모리 부족 시 디스크를 메모리처럼 사용하는 영역
    * `cpu`: `us`(user CPU), `sy`(system CPU), `wa`(wait I/O CPU), `st`(stolen time)
* `mpstat -P ALL 1`: CPU별 사용량
* `pidstat 1`: 프로세스별 CPU 사용량
* `iostat -xz 1`: I/O 상황을 확인, `await` 값은 읽거나 쓰기를 하기 위해서 대기하는 시간의 평균값, `avgqu-sz`는 해당 디바이스의 평균 요청 개수, `%util`은 디바이스 사용 비율
* `free -h`: 메모리 사용량
* `sar -n DEV 1`: 여러 서버의 정보 취합, `-n` 옵션으로 네트워크 상태 확인 가능
* `sar -n TCP,ETCP 1`: TCP를 통한 네트워크 처리 현황 확인 & TCP 처리 시에 발생한 에러들의 개수 확인, `active/s`는 장비에서 외부로 초기화된 초당 TCP 연결의 개수 & `passive/s`는 외부에서 장비로 초기화된 초당 TCP 연결의 개수 + `retrans/s`는 초장 재전송된 세그먼트의 총개수
* `top`: 시스템의 전반적인 현황 확인 가능하지만 CPU 부하 가중 가능성 높음

### 18. CPU 모니터링하기

#### 시스템의 CPU 사용량을 한 줄로 모니터링하는 도구들
* CPU, 디스크, 네트워크, 메모리는 반드시 모니터링하고 있어야 하는 항목이라고 할 수 있다.
* `vmstat`, `sar`, `mpstat`, `pidstat`, `top`
* 추가적으로 `sysstat` (리눅스 모듈)

#### mpstat의 기본적인 사용 방법
* 프로세서와 관련된 통계를 제공한다.
* 사용 가능한 CPU의 사용 상황을 제공해 준다. 각 데이터 출력 간격과 수행 횟수를 기본적으로 지정할 수 있다.
    * `명령어 데이터_출력_간격 수행_횟수` 순으로 지정한다.
    * 다른 명령어도 마찬가지
* 사용자 레벨/nice 우선순위로 사용자 레벨/시스템 레벨에서 수행되는 동안 사용한 CPU 시간의 비율, 하드웨어/소프트웨어 인터럽트를 CPU에서 처리하는 데에 사용한 비율 등의 수치를 제공한다.
* 인터럽트 통계, 데이터 출력 간격과 수행 횟수만 지정한 것과 동일한 결과 출력, 지정한 프로세서 혹은 모든 프로세서에 대한 사용량 출력, 모든 옵션에 대한 결과를 모두 출력하는 옵션이 있다.

#### 왜 CPU를 모니터링해야 하는 걸까?
* CPU는 병목이 가장 많이 발생하는 부분이다.
    * 어떻게 병목인지 알아내는 것도 중요하다. idle CPU를 제외하고 User CPU, System CPU, I/O Wait CPU, 기타 CPU 순으로 확인한다.
    * 보통 사용자 CPU 샤용량 비율이 높고, I/O가 높다면 애플리케이션에서 I/O 작업이 많다는 의미가 된다.

### 19. 전반적인 상황 모니터링하기 - vmstat과 sar

#### 대부붙의 유닉스와 리눅스에 설치되어 있는 vmstat
* 가상 메모리의 통계 정보(프로세스, 메모리, 페이징, 블록, I/O, 트랩스, 디스크, CPU)들을 제공한다.

#### vmstat의 기본적인 사용법
* `vmstat 시간 간격`으로 사용할 수 있다. 시간 간격 간의 평균값을 출력한다.
* 출력되는 가장 첫 번째 값은 시스템이 부팅된 이후 지금까지의 통곗값이므로 사용할 수 없다.
* 제공하는 정보는 아래와 같다.
    * `Procs`
        * `r`: 실행하기 위해 대기하고 있는 프로세스 수
        * `b`: 중단 불가능한 슬립 상태에 있는 프로세스 수
    * `Memory`
        * `swpd`: 가상 메모리 사용한 크기
        * `free`: 사용하지 않는 메모리 크기
        * `buff`: 버퍼로 사용하는 메모리 크기
        * `cache`: 캐시로 사용하는 메모리 크기
    * `Swap`
        * `si`: 초당 디스크에서 읽은 스왑된 메모리의 크기
        * `so`: 초당 디스크로 스왑된 메모리의 크기
    * `I/O`
        * `bi`: 블록 디바이스에서 받은 블록 수
        * `bo`: 블록 디바이스로 보낸 수
    * `System`
        * `in`: 클록을 포함한 초당 인터럽트 수
        * `cs`: 초당 컨텍스트 전환 개수
    * `CPU`
        * `us`: 사용자 코드를 수행하는 데에 소요된 시간
        * `sy`: 커널 코드 수행하는 데에 소요된 시간
        * `id`: idle 상태에서 수행된 시간
        * `wa`: I/O 대기하는 데에 소요된 시간
        * `st`: 가상 머신에서 뺏긴 시간
* `vmstat 옵션 delay count` 순으로 옵션을 지정할 수 있다.
    * active/inactive 메모리 사용량, 헤더 정보 출력 X, 출력 데이터 단위 지정, 부팅되었을 때부터 OS 상에서 생성된 작업의 총 개수, slab에 대한 정보 출력, 디스크의 사용량 통계(누적값), 디스크 파티션(`fdisk`로 파티션 확인 가능)에 대한 통계 정보를 제공하는 옵션들을 지정할 수 있다.

#### vmstat보다 상세한 정보를 알 수 있는 sar
* systat이 설치되어 있어야 한다.

#### sar의 기본적인 사용 방법
* 시스템의 작업 정보를 수집, 보고, 저장하는 도구로 모니터링 결과를 파일로 저장할 수 있는 옵션을 제공한다.
* `sar [ options ] [ <interval> [ <count> ] ]`와 같이 옵션을 지정할 수 있다.
* I/O와 전송률, 페이징 통계, 인터럽트 통계, 전원 관리 통계, 프로세서 통계, 네트워크 통계, CPU 사용 정보, 큐 길이와 부하 평균 등 다양한 정보를 제공하는 옵션들을 지정할 수 있다.
    * 파일 처리 및 출력 형태를 지정하는 옵션도 제공한다.

### 20. 프로세스 상황 모니터링하기

#### 프로세스 사이의 관계 알아보기
* 대부분의 프로세스는 혼자 떠 있지 않고 하나의 프로세스가 다른 프로세스를 띄우고 그 프로세스가 다른 프로세스를 띄울 수도 있다.
* `pstree` 명령어를 이용하면 프로세스 간의 관계를 확인할 수 있다.
    * 프로세스의 커맨드 옵션을 같이 출력하거나 프로세스 id를 함께 출력하는 등의 옵션을 제공한다.

#### 누구나 알고 있는 ps
* 현재 프로세스의 스냅샷 정보를 보여 준다.
    * `-e`, `-ef`, `-eF`, `-ely`: 표준 문법을 사용하여 시스템의 모든 프로세스 확인
    * `ax`, `axu`: BSD 문법 사용
    * `-ejH`, `axjf`: 프로세스 트리 출력
    * `-eo euser,ruser,suser,fuser,f,comm,label`, `axZ`, `-eM`: 보안 정보 출력
    * `-eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm`: 사용자가 정의한 포맷으로 프로세스 확인
    * `ps -C 프로세스 이름`: 지정한 프로세스 이름을 갖는 프로세스들의 목록 확인
* `ps -Lf -p 2250`과 같이 pid를 알고 있는 경우 `-p` 옵션을 사용하면 수행 결과도 빨리 나올 뿐 아니라 칼럼에 대한 타이틀도 출력한다.

#### 프로세스별로 CPU 사용량 모니터링하기
* `pidstat`
    * 서버에서 수행되는 작업의 통계를 제공한다. systat 8.0 이상 버전에서만 사용 가능하다.
    * 커맨드명이 포함된 명령어를 수행 중인 작업의 목록 출력, I/O 통계 정보 출력, 프로세스 정보 출력(`p`), 프로세스 명령어 이름과 옵션 출력, 페이지 오류와 메모리 사용 상태 출력, 선택 작업과 관련된 스레드의 통계 정보 출력 옵션 등을 제공한다.

* `pmap`
    * 프로세스의 메모리 맵 상황을 리포팅한다.
    * 확장된 데이터 출력, 디바이스 포맷으로 결과 출력, 몇몇 상하단 정보 생략하고 정보 출력 등의 옵션을 제공한다.

### 21. I/O 상황 모니터링하기

#### 디스크의 사용량을 알아보자
* 디스크가 꽉 차면 애플리케이션이 정상적으로 작동하지 못한다.
    * 로그가 쓰이지 않기 때문에 시스템이 멈추어 버리는 등의 문제가 발생할 수 있다.
* `df`
    * 파일 시스템의 디스크 공간에 대한 사용량 정보를 제공한다.
    * 모든 파일 시스템의 크기 보여 주기, 출력 결과의 단위 지정, 전체 합 출력, 출력 결과를 읽기 좋게 변환, inode 사용량 출력, 지정한 파일 시스템 타입에 해당하는 것만 출력하는 등의 옵션을 제공한다.
* `du`
    * 파일 공간의 사용량을 예측한다. 명령 수행 시 지정한 경로의 디렉터리 및 그 하위 디렉터리의 디스크 사용량을 종합하여 출력한다.
    * 디렉터리뿐 아니라 모든 파일 크기 출력, 전체 합 출력, 심벌릭 링크 포함한 결과 출력, 링크된 파일 크기 카운트 등의 옵션을 제공한다.
    * ex - `du -sh /usr/*`: `/usr` 하위 디렉터리들의 총 크기만을 읽기 좋게 출력

#### iostat을 알아보자
* CPU와 I/O에 대한 통계를 제공한다. vmstat처럼 시스템 부팅 이후 지금까지의 통계 정보를 보여 준다. 마찬가지로 간격과 수행 횟수 순서로 옵션을 지정한다.
    * CPU 사용량 정보, 디바이스 사용량 정보, NFS 사용량, 블록 디바이스와 시스템에서 사용되는 모든 파티션 정보 출력 등의 옵션이 있다.

#### 프로세스가 사용 중인 파일 확인하기
* `lsof`
    * 실행 중인 프로세스에서 열려 있는 파일의 목록을 제공한다.
    * 특정 pid를 갖는 프로세스에서 참조하는 파일 목록 출력, 특정 명령어로 수행된 프로세스에서 참조하는 파일 목록 출력, 경로명 처리 옵션 등을 제공한다.

### 22. 네트워크 상황 모니터링하기

#### sar로 네트워크 사용량 확인하기
* `sar -n`으로 `-n` 옵션을 사용하면 네트워크 사용량을 확인할 수 있다.
    * `-n { keyword [,...] | ALL }`
    * 네트워크 디바이스 통계, NFS 통계, IPv4 사용하는 (소켓) 네트워크 통계, TCPv4 사용하는 네트워크의 통계 등의 키워드를 제공한다.
    주로 `SOCK`, `TCP`, `ETCP`(TCP 에러 통계) 등을 사용한다.

#### lsof로 연결된 네트워크 정보 확인하기
* `lsof -i [46][protocol][@hostname|hostaddr][:service|port]`
    * IPv4/IPv6, TCP 등의 프로토콜과 함께 호스트 등을 지정할 수 있다.

### 23. 실시간으로 시스템 모니터링하기

#### 대부분의 리눅스에 설치되어 있는 top
* OS에서 수행 중인 작업들에 대한 정보를 보여 준다. 실시간으로 시스템에 대한 전반적인 상황과 각 프로세스의 목록을 제공해 준다.
    * 수행 중인 작업들에 대한 통계, CPU 사용량, 메모리 정보, 스왑 메모리 정보 등 다양한 정보를 제공한다.
    * O나 F로 항목 정렬을 변경할 수 있다.
    * 시작 옵션으로 사용자 입력 모드 대신 배치 모드로 켜 둘 수 있으며 커맨드 전체 경로와 옵션, 스레드 출력, idle 프로세스 제외 출력 등 다양한 모드를 지정 가능하다.
* 비슷한 도구로 `htop`이 있다.
    * 조금 더 보기 좋게 결과를 제공한다.
    * 기본적으로 리눅스에 설치되어 있지는 않으므로 직접 설치해 주어야 한다.
    * 명령어 자체의 APU 점유율이 높으므로 서버 사양이 좋아 무리가 없을 경우에만 사용하는 것이 좋다.

### 25. 장애 진단은 이렇게 한다
* 장애가 났을 때 가장 먼저 할 일
    * 장애 유형 확인(증상 확인)
    * 시스템 기본 정보 확인
    * 데이터 통한 원인 진단
    * 원인이 발견되었을 경우 제거 후 확인
    * 진단 결과 보고서 작성

#### 본격적인 진단 시작하기
* 어떤 정보들이 의심이 되는지를 정리해 두자.
* 장애 상황을 재현시켜 문제점을 찾아내도록 한다.
* 원인을 제거하고 결과를 정리한다.
    * 원인을 수정하고 난 뒤에는 장애가 정말 사라졌는지 모니터링한다.
* 장애 보고서에는 아래와 같은 내용이 들어가면 나중에 참고하기 쉽다.
    * 개요: 장애의 증상과 시기, 장애가 발생한 서버의 스펙과 사용 중인 소프트웨어 버전, 진단에 참여한 인원/진단 기간/사용 도구, 기타 각종 상황
    * 진단 내역 및 원인: 가장 효과가 많은 부분부터 원인 작성(ex - 응답에 10초가 소요되었고 수정 후 1초가 되었을 때 9초를 잡아먹은 장애가 발생한 원인), 가능하다면 진단의 절차와 문제가 된 코드나 부분에 대한 로그 파일 내용 포함
    * 해결 방안: 반영 전후의 차이
    * 종합 의견
    * 권고 사항: 문제가 발생할 수 있는 부분에 대한 정리