---
title: "Kotlin in Action 2장; 코틀린 기초"
categories:
  - Language
tags:
  - kotlin
toc: true
toc_label: "Contents"
toc_sticky: true
---

### 2. 코틀린 기초

* 함수, 변수, 클래스, `enum`, 프로퍼티를 선언하는 방법
* 제어 구조
* 스마트 캐스트
* 예외 던지기와 예외 잡기



#### 2.1 기본 요소: 함수와 변수

##### Hello, World!

```kotlin
fun main(args: Array<String) {
  println("Hello, world!")
}
```

* 함수 선언 시 `fun` 키워드를 사용한다.
* 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
* 함수를 최상위 수준에 정의할 수 있다.
* 배열도 일반적인 클래스와 마찬가지다.

##### 함수

```kotlin
fun max(a: Int, b: Int): Int {
  return if (a > b) a else b
}
```

* 함수 선언은 `fun` 키워드로 시작하고, 그 다음 함수 이름이 온다.
* 이름 뒤에는 괄호 안에 파라미터 목록이 온다. 함수 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론(`:`)으로 구분해야 한다.

> 코틀린에서 `if`는 식이지 문이 아니다. 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상의 요소로 존재하며 아무런 값을 만들어 내지 않는다는 차이가 있다. 코틀린에서는 루프를 제외한 대부분의 구조가 식이다. 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다.

* 식 하나로만 이루어진 함수의 경우 더 간결하게 함수를 표현할 수 있다.
  * 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라 부르고 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

> 인텔리제이는 이 두 방식의 함수를 서로 변환하는 메뉴가 있다. *Convert to expression body*와 *Convert to block body*로 가능하다.

* 반환 타입의 생략도 가능하다.
  * **식이 본문인 함수**의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해 준다.
  * 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해 주는 기능을 **타입 추론**이라 한다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

* 블록이 본문인 함수가 값을 반환한다면 반드시 타입을 지정하고 `return` 문을 사용해 반환 값을 명시해야 한다.

##### 변수

* 타입 지정을 생략하는 경우가 많다. 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없기 때문이다.
* 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

```kotlin
val question = "dinner menu?"
val answer = 42
val age: Int = 24
```

* 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다. 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
* 변수 선언 시 사용하는 키워드는 다음과 같은 2가지가 있다.
  * `val`: 변경 불가능한 참조를 저장하는 변수다. 초기화하고 나면 재대입이 불가능하다.
  * `var`: 변경 가능한 참조다. 자바의 일반 변수에 해당한다. 
* 기본적으로는 모든 변수를 `val` 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 `var`로 변경하는 게 낫다. 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.
* `val` 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 `val` 값을 다른 여러 값으로 초기화할 수 있다.

```kotlin
val message: String
if (operation()) {
  message = "success"
  // ...
} else {
  message = "fail"
}
```

* `val` 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

```kotlin
val languages = arrayListOf("java")
languages.add("c")
```

* `var` 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.
  * 컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며 변수 선언 이후 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.

##### 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
  val name = if (args.size > 0) args[0] else "kotlin"
  println("Hello, $name!")
}
```

* 변수를 문자열 안에 사용할 수 있다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 `$`를 추가해야 한다.
* `$` 문자를 문자열에 넣고 싶으면 `println("\$x")`와 같이 `\`를 사용해 이스케이프시켜야 한다.
* 복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.

```kotlin
fun main(args: Array<String>) {
  if (args.size > 0) {
    println("Hello, ${args[0]}!")
  }
}
```

> 문자열 템플릿 안에 `$`로 변수를 지정할 때 변수명 뒤에 한글을 붙여서 사용하면 코틀린 컴파일러는 영문자와 한글을 한꺼번에 식별자를 인식해서 오류를 발생시킨다. 변수 이름을 중괄호로 감싸면 해결 가능하다.

* 중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.



#### 2.2 클래스와 프로퍼티

```java
/* java */
public class Person {
  private final String name;
  
  public Person(String name) {
    this.name = name;
  }
  
  public String getName() {
    return name;
  }
}
```

* 자바에서는 생성자 본문에 같은 코드가 반복적으로 들어가는 경우가 많다. 코틀린에서는 필드 대입 로직을 훨씬 더 적은 코드로 작성할 수 있다.

```kotlin
class Person(val name: String)
```

* 이런 유형의 클래스(코드가 없이 데이터만 저장하는 클래스)를 **값 객체**라고 부른다.
* 코틀린의 기본 가시성은 `public`이므로 변경자를 생략해도 된다.

##### 프로퍼티

* 클래스의 목적은 데이터를 캡슐화하고 캡슐화한 뎅터를 다루는 코드를 한 주체 안에 가두는 것이다. 자바에서는 데이터를 필드에 저장하며 멤버 필드의 가시성은 보통 비공개(`private`)다.  클래스느느 자신을 사용하는 클라이언트가 데이터에 접근하는 통로로 쓸 수 있는 접근자 메소드를 제공한다.
  * 자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부르며, 프로퍼티 개념을 활용하는 프레임워크가 많다.
* 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며 자바의 필드와 접근자 메소드를 완전히 대신한다.
  * 클래스에서 프로퍼티를 선언할 때는 `val`이나 `var`를 사용한다.

```kotlin
class Person (
  val name: String,
  var isMarried: Boolean
)
```

* 기본적으로 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다.
  * 코틀린은 값을 저장하기 위한 비공개 필드와 세터, 게터로 이루어진 간단한 디폴트 접근자 구현을 제공한다.
* 위의 자바로 작성한 클래스와 코틀린으로 작성한 클래스는 동일하게 구현된 클래스이다.
  * 어느 쪽을 사용해도 코드를 바꿀 필요가 없다.
  * 게터와 세터의 이름을 정하는 규칙에는 예외가 있는데, 이름이 `is`로 시작하는 프로퍼티의 게터에는 원래 이름을 그대로 사용한다. 세터에는 `is`를 `set`으로 바꾼 이름을 사용한다.

> 자바에서 선언한 클래스에 대해 코틀린 문법을 사용해도 된다.

##### 커스텀 접근자

* 프로퍼티의 접근자를 직접 작성하기
  * `isSquare` 프로퍼티에는 자체 값을 저장하는 필드가 없이 자체 구현을 제공하는 게터만 존재한다.
  * 게터가 프로퍼티 값을 매번 다시 계산한다. 이를 자바에서 사용하려면 `isSquare` 메소드를 호출하면 된다.

```kotlin
class Rectangle(val height: Int, var width: Int) {
  val isSquare: Boolean
    get() {
      return height == width
    }
}
```

* 파라미터가 없는 함수를 정의하는 방식과 커스텀 게터를 정의하는 방식 모두 비슷하다. 구현이나 성능상 차이는 없다.
  * 일반적으로 클래스의 특성을 정의하고 싶다면 프로퍼티로 그 특성을 정의해야 한다.

##### 코틀린 소스코드 구조: 디렉터리와 패키지

* 코틀린에도 자바와 비슷한 개념의 패키지가 있으며 모든 코틀린 파일의 맨 앞에 `package` 문을 넣을 수 있다. 그러면 그 파일에 있는 모든 선언이 해당 패키지에 들어간다.
* 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다. 다른 패키지의 경우 임포트를 통해 불러온다.

```kotlin
package geometry.shapes

import java.util.Random

// ...
```

* 코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며 모든 선언을 `import` ZLDNJEMFH RKWUDHF TN DLTEK.
* `.*`로 패키지 안의 모든 선언을 임포트할 수 있다. 클래스뿐 아니라 최상위에 정의된 함수나 프로퍼티까지 불러온다.
* 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고 파일의 이름도 마음대로 정할 수 있다.
  * 디스크상의 어떤 디렉터리에 소스코드 파일을 위치시키든 관계없다. 원하는 대로 소스코드를 구성할 수 있다.
  * 하지만 대부분의 경우 자바-코틀린 간 마이그레이션을 위해 자바와 같이 패키지별로 디렉터리를 구성하는 폇이 낫다.



#### 2.3 선택 표현과 처리: enum과 when

